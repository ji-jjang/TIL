# 클라이언트 핸들링
- 클라이언트 연결을 수락하는 데 **TCP 포트와 유닉스 소켓** 사용할 수 있음
- 일반적으로 TCP 포트를 사용하지만, 설정 파일에서 unixsocket 및 unixsocketperm 매개변수를 설정하면 원하는 경로에 소켓 파일을 생성하고 해당 파일의 권한 지정 가능
```redis
unixsocket /tmp/redis.sock
unixsocketperm 777

redis-cli -s /tmp/redis.sock # 클라이언트가 해당 유닉스 소켓 파일의 경로를 사용해 레디스 서버에 연결
```
- 레디스는 **멀티플렉싱(Multiplexing)방식**을 사용하며, 이로 인해 하나의 통신 채널을 통해 여러 데이터 스트림을 전송
- **하나의 스레드에서 여러 소켓을 감시하고, 소켓 이벤트가 발생하는지 지속적으로 확인**할 수 있기에 효율적인 다중 클라이언트 지원. 많은 클라이언트 요청을 동시에 처리하는데 블로킹 문제 피할 수 있음
- **논블로킹 I/O**를 이용해 I/O 작업이 완료될 때까지 대기하지 않고 다른 작업을 처리할 수 있음
- 레디스는 클라이언트 커넥션을 생성할 때 **TCP_NODELAY** 옵션 사용. 소켓은 작은 데이터라도 버퍼링하지 않고 지연 없이 가능한 한 빨리 패킷으로 전송하려 시도. 작은 데이터 조각을 실시간으로 전송해야 하는 사용되며, 클라이언트 연결 지연 최소화 

> redis 버전 7을 기준으로 레디스와 클라이언트 통신할 때 TCP_NODELAY 옵션 해제할 수 없음. 하지만 복제 연결을 할 때에는 `repl-disable-tcp-nodelay yes`로 옵션 해제. 복제본에 데이터를 전송할 때 더 작은 수의 TCP 패킷과 대역폭을 사용하지만, 데이터가 복제본에서 나타나기까지 약 40 밀리초 지연 발생할 수 있음. 대규모 트래픽 상황 또는 마스터와 복제본 사이의 거리가 멀 경우 이 값을 yes로 고려 필요 
- 클라리언트 소켓에서 새로운 데이터 도착 시 읽기 가능한 파일의 이벤트 생성. 레디스는 이를 이용해 클라이언트에서 전송한 쿼리를 수집하고 처리. 클라이언트가 초기화되면 레디스는 maxclients 설정 값과 비교해 현재의 클라이언트 수가 maxclients 값에 도달했는지 확인. 이 값을 초과하면 새로운 클라이언트 접속 거부

## 클라이언트 버퍼 제한
- **레디스는 클라이언트에 반환할 데이터를 임시로 저장하기 위해 각 클라이언트마다 `클라이언트 출력 버퍼 생성`**
- 출력 버퍼는 레디스가 반환할 데이터 양에 따라 가변된 길이를 갖게 되지만 만약 클라이언트가 데이터를 처리하지 못하고 계속해서 서버에 요청을 보내면 서버의 출력 버퍼  계속해서 증가하며, 메모리가 증가. 특히 pub/sub에서 발행자가 보낸 새로운 메시지를 구독자가 처리하는 속도가 충분하지 않은 경우에 문제 발생
- **레디스는 출력 버퍼 크기에 제한을 두어 버퍼 크기가 일정 수준 이상으로 증가할 경우 클라이언트 연결 종료**. 하드 제한은 고정된 제한값으로 여기에 도달하면 레디스는 클라이언트 연결을 가능한 빨리 닫음. 소프트 제한은 시간에 따라 다르며 특정 크기보다 큰 출력버퍼를 유지한 경우 연결 닫음 
- 기본적으로 일반 클라이언트 출력 버퍼 제한이 **0으로 설정**. 하나의 커맨드를 보내고 다음 커맨드를 보내기 전에 응답을 기다리기 때문

### 1. pub/sub 클라이언트
- 기본 하드 제한 32MB, 소프트 제한은 60초당 8MB. pub/sub 클라이언트는 빠르게 처리되는 메시지들을 처리하기 위해 더 많은 메모리 공간 필요하기 때문

### 2. 복제본
- 기본 하드 제한 256MB, 소프트 제한은 60초 64MB. 이는 복제본이 마스터 서버로부터 대량의 데이터를 받아들이는 경우가 많아 더 큰 출력 버퍼가 필요하기 때문
```redis
CONFIG SET client-output-buffer-limit <class> <hard-limit> <soft-limit> <soft-limit-duration>

CONFIG SET client-output-buffer-limit "slave 0 0 0" // 복제 클라이언트의 limit 값 모두 제거
```
- 여기서 class는 normal, slave(replica), pubsub 중 하나. normal은 일반 레디스 클라이언트. slave와 replica는 복제본 클라이언트. pubsub은 pub/sub 클라이언트

### 쿼리 버퍼
- **클라이언트 쿼리 버퍼는 클라이언트에서 받은 커맨드를 레디스에서 잠시 보관하는 내부 버퍼**
- 클라리언트가 레디스 서버에 커맨드를 전송하면 레디스 서버는 이를 쿼리 버퍼에 저장한 뒤 처리 쿼리 버퍼의 크기는 기본적으로 1GB 설정. 특별한 상황에서 이 값을 조절해야 한다면 `client-query-buffer-limit` 설정으로 변경

## 클라이언트 이빅션
- 클라이언트 연결에 메모리를 과다해 사용하면 OOM 또는 데이터 이빅션 유발
- 이전 버전에서는 클라이언트 연결과 데이터를 저장하는데 사용하는 메모리를 통합해 `maxmemory-policy` 설정값으로 메모리 한도 제한. 레디스 7.0부터는 `maxmemory-clients` 설정값을 사용해 누적 메모리양 제한. **서버는 가장 많은 메모리를 사용하는 연결부터 해제하려고 시도하며, 이 기능을 클라이언트 이빅션이라고 함.**
- maxmemory-clients 설정값은 레디스에 연결된 모든 클라이언트의 최대 총 메모리 사용량을 정의. 쿼리 버퍼, 출력 버퍼, 중간 버퍼와 같은 구성 요소 포함. 이빅션이 발생하면 maxmemory-clients 임계치를 초과하지 않도록 가장 많은 메모리를 사용하는 클라이언트부터 제거하여 최소한의 클라이언트 연결 해제
- 복제 연결에 사용되는 **복제본과 마스터 커넥션은 이빅션 기능에 영향을 받지 않기에** 복제 과정에서 사용하는 메모리 양이 많더라도 이 설정에 의해 복제 연결은 자동으로 끊어지지 않음
- 특정 클라이언트 연결을 이빅션에 제외할 수 있음. `CLIENT NO-EVICT ON`

## Timeout과 TCP Keepalive
- **레디스 서버에 클라이언트가 연결되면, 장기간 동안 커맨드를 수행하지 않더라도 연결은 계속 유지**
- 특정 시점에 활동이 없는 클라이언트를 정리하려면 타임아웃 설정 사용. `CONFIG SET timeout 600`
- 이는 레디스 유휴 연결이 쌓여 서비스 장애가 발생하는 상황을 방지. 기본값 0

# 파이프라이닝
- 레디스 서버와 클라이언트는 네트워크를 통해 연결되어 있으며, 요청과 응답 사이의 왕복 시간(RTT)은 성능에 큰 영향
- 왕복시간이 250ms인 경우 레디스 서버가 초당 10만 개의 요청을 처리할 수 있더라도 네트워크 통신에 소요되는 시간 때문에 초당 최대 4개의 요청만을 처리 
- **파이프라이닝은 클라이언트가 연속적으로 여러 커맨드를 레디스 서버에 보낼 수 있도록 하는 기능**. 레디스 서버에 줄바꿈을 이용해 동시에 실행할 여러 개의 커맨드를 한 번에 보냄
- 파이프라이닝을 이용하면 왕복 시간을 줄일 수 있는 것 뿐만 아니라 레디스 서버 처리량도 크게 향상
- **레디스 서버가 클라이언트에 응답하기 위해 소켓 I/O를 수행할 때 운영체제 커널 영역의 read(), write() 시스템 콜을 호출하는 과정에서 발생하는 레이턴시 증가가 레디스 서버에서 데이터를 찾고 반환하는 과정보다 큼. 파이프라이닝을 사용하면 여러 명령이 단일 read() 시스템 콜로 읽혀지고 여러 응답이 단일 write() 시스템 콜 호출로 전달되기에 시스템 콜을 줄일 수 있음**

## 주의 사항
- 한 번에 너무 많은 쿼리를 파이프라인을 이용해 레디스에 보내면 네트워크 대역폭 한계로 인해 속도 저하와 쿼리 버퍼 제한에 걸려 오류 발생 가능성
- 명령을 일정한 개수로 나누어 배치 형태로 서버에 보내는 것이 좋음
- 파이프라이닝을 이용한 연결은 원자적이지 않고, 트랜잭션 개념이 아니기에 여러 커맨드 중 일부에 오류가 발생하더라도 롤백되지 않음. 오류 발생 시킨 커맨드만 적용되지 않음

# 클라이언트 사이드 캐싱
- 클라이언트와 레디스 서버 간 통신에서 가장 많은 시간을 차지하는 것은 네트워크 I/O. **쿼리가 들어올 때마다 레디스 서버에 데이터를 요청하는 대신, 클라이언트 측에서 데이터를 로컬에 캐싱하고 필요할 때 데이터를 반환하는 것을 클라이언트 사이드 캐싱**
- 서버는 레디스에 데이터를 요청한 뒤 결과를 가져옴. 하지만, 클라이언트 사이드 캐싱을 사용하면 애플리케이션은 자주 사용되는 쿼리의 응답을 애플리케이션 메모리 내 저장해, 나중에 저장소에 다시 쿼리하지 않고도 응답을 재사용.
- 데이터셋의 아이템이 자주 변경되지 않는 상황에서는 클라이언트 사이드 캐싱을 사용하는 것이 합리적
- 데이터 정합성 문제. **레디스 클라이언트 사이드 캐싱에서는 이를 처리하는 방법을 트래킹이라 함** 
## 1. 기본 모드 
- 레디스 서버가 클라이언트가 액세스한 키를 기억해서, 동일한 키가 수정될 때 무효 메시지를 전송. 레디스 서버에서 이를 기억해야 하기에 메모리 비용이 들지만, 정확하게 클라이언트가 갖고 있는 키에 대해서만 무효 메시지를 보낼 수 있다는 장점

## 2. 브로드캐스팅 모드
- 레디스 서버가 모든 키에 대한 액세스를 기억하려고 시도하지 않으며, 특정 프리픽스에 대해 접근한 클라이언트만 기억하기에 기본 모드보다 레디스 서버에서 사용하는 메모리가 적다는 장점
- 대신 클라이언트는 특정 프리픽스를 가진 키를 기억해야 하며, 자신이 소유하지 않은 키라 하더라도 해당 프리픽스와 일치하는 키가 변경될 때마다 변경 메시지를 수신하는 단점 존재하여 CPU 자원 소모
