# 레디스 복제 구조
$Availability = {Available for Use Time} / {TotalTime}$
- **가용성이란 일정 기간 동안 서비스를 정상적으로 사용할 수 있는 시간의 비율**
- 고가용성 확보
  - 복제: 마스터 노드의 데이터를 복제본 노드로 실시간 복사하는 기능, 마스터 노드의 서버에 장애가 생겨 데이터가 유실된다 해도 복네본 노드에서 데이터를 확인
  - 자동 페일오버: 마스터 노드에서 발생한 장애를 감지해 레디스로 들어오는 클라이언트 연결을 자동으로 복제본 노드로 리다이렉션하는 기능. 수동으로 레디스의 엔드포인트를 변경할 필요가 없어 빠른 장애 조치가 가능
- 두 가지 기능 중 어느 하나라도 정상적으로 동작하지 않는다면 고가용성을 확보할 수 없다.

## 복제 구조 구성하기
- 복제본 노드를 추가하는 이유
  - 실행 중인 하드웨어는 언제든지 고장날 수 있으므로, 마스터 데이터베이스가 다운됐을 때 대신 사용할 여분의 복제본 필요
  - 대규모 서비스에서 복제본은 트래픽 감소 역할 (부하 분산)
  - 백업을 복제본에서 수행하면 백업 작업이 서비스에 미치는 영향 최소화
- MySQL이나 PostgreSQL은 멀티 마스터 복제 구조를 제공하기에 모든 노드가 마스터이면서 복제본이 되는 구조 가능, 레디스는 멀티 마스터 구조를 지원하지 않음. 복제본은 마스터에서 변경된 데이터를 그대로 받아옴
```redis
REPLICAOF <master-ip> <master-port>
```
- 복제 연결하는 커맨드. 레디스의 데이터를 업데이트하는 모든 커맨드는 노드 A에서 실행되기 때문에 서비스 애플리케이션은 마스터 노드인 A의 노드 정보를 바라봄. 예기지 못한 장애에 연결 설정을 B로 변경하면 서비스를 계속할 수 있음
- 레디스 마스터에는 여러 개의 복제본 연결 가능, 복제본 노드에 새로운 복제본 추가하는 것 가능. 하지만, 한 개의 복제 그룹에선 항상 한 개의 마스터 노드만 존재. 가장 상위인 마스터 노드만 데이터 업데이트 커맨드 가능, 하위 복제본은 모두 읽기 전용

## 패스워드 설정
- 데이터를 복제할 때에는 masterauth 옵션에 패스워드 입력
- requirepass 옵션으로 패스워드 설정
- 복제본 노드는 masterpass 옵션에 마스터의 requirepass에 설정된 패스워드 값 입력, 해당 값 없을 때는 master에 연결해 데이터를 받아갈 수 없음
- 복제본 노드에서 requirepass를 다른 값으로 설정해 각 레디스 노드에 접근할 때 다른 패스워드를 사용할 수도 있지만, 하나의 복제 그룹에 속한 마스터와 복제본 노드는 같은 패스워드로 설정하는 것이 일반적
```redis
CONFIG SET masterauth mypassword
> OK

CONFIG REWRITE
> OK
```
- 복제본 인스턴스 설정 파일을 직접 수정한 후 인스턴스 재시작하거나 실행 주인 복제본 인스턴스에서 위와 같은 방법으로 옵션을 수정한 뒤 설정 파일을 다시 작성할 수도 있음

# 복제 매커니즘

## 버전 7 이전(repl-diskless-sync 기본값 no)
```redis
1. REPLICAOF 커맨드로 복제 연결 시도
2. 마스터 노드에서는 fork로 자식 프로세스를 새로 만든 뒤 RDB 스냅숏 생성
3. 2번 과정 동안 마스터 노드에서 수행된 모든 데이터셋 변경 작업은 레디스 프로토콜 형태로 마스터의 복제 버퍼에 저장
4. RDB 파일이 생성 완료되면 파일은 복제본 노드로 복사
5. 복제본에 저장됐던 모든 내용을 삭제한 뒤 RDB 파일을 이용해 데이터 로딩
6. 복제 과정 동안 버퍼링됐던 복제 버퍼의 데이터를 복제본으로 전달해 수행
```
- 복제 요청을 받은 마스터 노드가 BGSAVE 커맨드로 디스크에 RDB 파일을 생성하는 로그를 볼 수 있음 
- 복제본 노드에서는 마스터와의 통신을 확인 후 마스터로부터 RDB 파일을 읽어오고, 로그하는 과정 
- 복제 속도는 디스크 I/O 처리량에 영향. 

## 버전 7 이후(repl-diskless-sync 기본값 yes)
```redis
1. REPLICAOF 커맨드로 복제 연결 시도
2. 마스터 노드는 소켓 통신을 이용해 복제본 노드에 바로 연결, RDB 파일은 생성됨과 동시에 점진적으로 복제본 소켓에 전송
3. 2번 과정 동안 마스터 노드에서 수행된 모든 데이터셋 변경 작업은 레디스 프로토콜 형태로 마스터의 복제 버퍼에 저장
4. 소켓에서 읽어온 RDB 파일 복제본 디스크에 저장
5. 복제본에 저장됐던 모든 내용을 모두 삭제한 뒤 RDB 파일 내용을 메모리에 로딩
6. 복제 버퍼의 데이터를 복제본으로 전달해 수행
```
- **소켓에서 읽어온 RDB 스냅숏 데이터를 바로 메모리에 로드하지 않고, 일단 복제본 노드 디스크에 저장하는 과정**
- 복제본 노드는 마스터에서 가져온 데이터를 불러오기 전 자신의 데이터를 모두 삭제하는 과정을 거쳐야 한다. 소켓 통신으로 받아온 RDB 데이터가 정상적인지 미리 확인할 수 없기 때문에 모두 삭제하기 전 자신의 디스크에 데이터를 저장하는 과정을 선행하여 데이터의 안정성 확보
- 디스크 I/O가 느리고 네트워크가 빠른 경우 디스크를 사용하지 않는 복제 방식을 사용하는 것이 더 빠르게 복제 연결을 완료할 수 있는 방법
- 기존 디스크를 사용하는 복제를 사용했을 경우 RDB 파일이 생성되는 도중 다른 노드에서 복제 연결 요청이 들어오면 이 연결은 큐에 저장되며 기존 RDB 파일의 저장이 완료되면 여러 복제본이 한 번에 복제 연결을 시작
- 디스크를 사용하지 않는 방식에서 이미 하나의 복제본으로 복제 연결이 시작된 경우 복제 과정이 끝나기 전 다른 복제본과의 연결을 할 수 없으며, 다른 복제본들은 하나의 복제 연결이 끝날때까지 큐에서 대기. 이를 방지하기 위해 `repl-diskless-sync-delay 5` 옵션 사용 가능. 새로운 복제 연결이 들어오면 5초를 기다린 뒤 복제 연결 시작

## 비동기 방식으로 동작하는 복제 연결
- 정상적으로 복제 연결이 된 상태에서 마스터에서 복제본으로의 데이터 전달은 **비동기 방식으로 동작**
- 레디스 마스터 노드가 비정상 종료된 경우ㅂ데이터는 복제본 노드에 전달되지 않은 상태이기에 유실될 가능성 존재. 하지만 실제로 데이터가 굉장히 빠르게 전달되기 때문에 데이터 유실이 빈번하게 발생하지 않음
  
## 복제 ID
- 모든 레디스 인스턴스는 복제 ID를 가짐
- 복제 기능을 사용하지 않은 인스턴스라도 모두 랜덤 스트링 값의 복제 ID를 가지며, 복제 ID는 오프셋과 쌍으로 존재. 레디스 내부ㄹ데이터가 수정되는 모든 커맨드를 수행할 때마다 오프셋 증가
- `INFO REPLICATION`으로 복제 연결 상태 확인 가능
- **복제 연결을 시작하면 복제본의 replication id는 마스터의 replication id로 변경되며, 오프셋은 복제본에서 마지막으로 수행된 마스터의 오프셋을 의미**
- replication id와 오프셋이 같을 때 두 노드는 정확히 일치된 상태라는 것을 의미

## 부분 재동기화
- **복제 연결이 끊길 때마다 마스터에서 RDB 파일을 새로 내려 복제본에 전달하는 과정을 거친다면 네트워크가 불안정한 상황에서 복제 기능을 사용하는 레디스의 성능은 급격하게 악화**
- 이를 위해 레디스는 부분 재동기화 기능을 지원한다.
- **마스터는 커넥션 유실을 대비해 백로그 버퍼라는 메모리 공간에 복제본에 전달한 커맨드 데이터들을 저장한다. 하나의 복제 그룹에서 replication id와 오프셋을 이용하면 복제본이 마스터의 어느 시점까지의 데이터를 가지고 있는지 파악 가능**. 만약 복제 연결이 잠시 끊긴 뒤 재연결되면 복제본은 **PSYNC 커맨드를 호출해 자신의 replication id와 오프셋을 마스터에 전달**한다. 마스터는 **RDB 파일을 새로 저장할 필요 없이 백로그에 저장된 내용을 복제본에 전달함으로써 부분 재동기화를 진행**한다.
- 하지만, 마스터의 백로그 버퍼에 원하는 데이터가 남아 있지 않거나, 복제본이 보낸 replication ID가 현재 마스터와 일치하지 않는다면 전체 재동기화를 시도
- 복제 백로그 크기는 `repl-backlog-size` 파라미터로 설정. 기본값은 1MB. 백로그는 1개 이상의 복제본이 연결된 경우에만 할당되며, `repl-backlog-ttl`만큼의 시간이 경과하면 메모리에서 백로그 공간 삭제
- 복제본은 언제든지 마스터로 승격할 수 있기에 복제본에 직접 연결된 복제 연결이 따로 없더라도 백로그 버퍼를 해제하지 않음

## Secondary 복제 ID
- **한 개의 복제본 그룹 내 모든 레디스 노드는 동일한 복제 ID**를 갖음
- A 노드에 장애, 복제본 B노드가 새로 승격되는 상황
  - 마스터 노드와의 복제가 끊어짐과 동시에 복재본은 새로운 복제 ID 갖음. 만약 장애가 해결된 뒤 기존 마스터 노드였던 A와 연결될 때 두 노드는 동일한 복제 ID를 가질 수 있기 때문임. 동일한 오프셋이 동일한 데이터셋을 갖는다는 사실 위반 가능성
  - B가 새로운 마스터로 승격됨과 동시에 새로운 복제 ID를 가짐. 노드 C가 노드 B에 복제 연결이 될 때 두 노드의 master_replid2가 같기(기존 복제 ID) 때문에 C노드는 B노드에 부분 재동기화를 시도. 노드 B와 노드 C 모두 기존 A 노드 복제본으로 동일한 데이터셋을 가지고 있었기에 노드 B의 백로그가 재동기화를 하기 위한 데이터를 갖고 있는 경우 부분 재동기화만으로 노드 C가 B에 연결(빠르게 복제 상태 구축 가능)
## 읽기 전용 모드로 동작하는 복제본 노드
- 복제본은 기본으로 읽기 전용 모드로 동작
- 특정 상황에서 마스터 노드에서 수행하기에는 오래 걸리는 연산을 테스트하기 위한 용도로 복제본의 `replica-read-only` 옵션 설정을 해제하고 싶을 수 있다. 이 경우 **복제본 노드의 데이터가 변경되더라도 복제본이 재시작되거나 커넥션이 유실돼 마스터와 전체 재동기화를 수행하게 되면 복제본에서 수행한 데이터는 사라지기 때문에 주의**
- 복제본에 직접 데이터를 쓸 수 있다 하더라도 복제본에 쓰는 내용은 오직 로컬에서만 유지, 해당 노드에 연결된 복제본으로는 전파되지 않음

## 유효하지 않은 복제본 데이터
- **유효하지 않은 데이터란 복제본의 데이터와 마스터의 데이터가 정확하게 일치하지 않는 경우**
- 복제본과 마스터가 연결이 끊어진 상태, 혹은 복제 연결이 시작된 뒤 아직 완료되지 않았을 경우 복제본의 데이터가 유효하지 않음
- 복제본의 데이터가 유효하지 않다고 판단될 때 복제본은 `replica-serve-stale-data` 파라미터를 이용해 제어 가능, 기본값은 yes로 데이터가 유효하지 않다고 판단될 때에도 클라이언트로부터 들어오는 모든 읽기 요청에 데이터를 반환. 이 값을 no로 설정하면 일부 기본 커맨드를 제외한 모든 커맨드에 대해 동기화 오류 에러가 발생

## 백업을 사용하지 않는 경우 데이터 복제
- 레디스에서 복제를 사용하지 않는 경우 마스터와 복제본에서 백업 기능을 사용하는 것을 권장
- 백업을 사용하지 않으려면 재부팅 후 레디스가 자동으로 재시작되지 않도록 설정하는 것을 권장
- 복제 구조에서 백업 설정하지 않았을 경우
  1. 백업 기능을 사용하지 않는 마스터와 복제본 노드 존재
  2. 마스터 노드가 장애로 인해 종료됐지만, 레디스 프로세스를 자동 재시작하는 시스템에 의해 노드가 재부팅. 메모리 내용 초기화
  3. 복제본 노드 간 데이터 존재, 마스터 노드로의 복제 연결 시도
  4. 마스터에서 복제본으로 빈 데이터 셋 전달
- **자동 재시작 기능을 사용하지 않았다면 복제본 노드에는 데이터가 존재하기 때문에 애플리케이션 연결 설정을 마스터에서 복제본 노드로 변경해 데이터를 계속 사용할 수 있었음 또는 복제본 노드에서 데이터를 새로 백업받아 마스터 노드에 전달한 뒤 마스터 노드를 시작시키면 복제본 노드에 저장된 내용으로 데이터 복원 가능했음**
- 데이터 안정성을 위해 복제 기능을 사용할 경우 백업 기능을 사용하지 않는 것이 권장. 그렇지 않을 경우 마스터에서는 인스턴스의 자동 재시작을 활성화하지 않는 것을 권장
