# 메시징 큐와 이벤트 스트림
- 최근 서비스 아키텍처는 느슨하고 적절한 연결, 가용성 및 성능을 위한 비동기 통신 -> 어딘가에 메시지를 쌓아둔 뒤 나중에 처리할 수 있는 채널이 필요하고, 이것이 메시지 브로커의 핵심 역할이다.
- 메시지 브로커는 크게 메시징 큐와 이벤트 스트림이라는 두 가지 형태로 나눌 수 있다.
- 메시징 큐에서는 주로 데이터를 생성하는 쪽을 생성자(producer), 데이터를 수신하는 쪽을 수신자(consumer)로 지칭한다.
- 이벤트 스트림에서는 주로 데이터를 생성하는 쪽을 발행자(publisher), 데이터를 조회하는 쪽을 구독자(subscriber)로 지칭한다.

## 차이점
### 1. 방향성
- 메시징 큐의 생산자는 소비자의 큐로 데이터를 직접 푸시한다. 2개의 서비스에 같은 메시지를 보내야 할 때 메시징 큐를 이용한다면 생산자는 2개의 다른 메시징 큐에 각각 데이터를 푸시해야 한다. 반면 스트림을 이용한다면 특정 저장소에 하나의 메시지를 보낼 수 있고, 소비자들은 스트림에서 같은 메시지를 받을 수 있기에 메시지를 복제해서 저장하지 않아도 된다.

### 2. 영속성
- 메시징 큐에서는 소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제한다. 이벤트 스트림에서는 구독자가 읽어간 데이터는 바로 삭제되지 않고, 저장소의 설정에 따라 특정 기간 동안 저장될 수 있다. 

### 3. 확장성
- 메시지를 보내는 중에 새로운 소비자를 추가할 때도 메시지 큐를 이용한다면 새롭게 추가된 이후의 이벤트만 확인할 수 있다. 스트림 방식에서는 메시지를 생상할 때 구독자를 지정하지 않고, 스트림에 쌓인 데이터는 일정 기간 동안 지워지지 않기 때문에 새로 추가된 서비스도 스트림에 남아 있는 이전 데이터의 히스토리를 볼 수 있다.
- 메시징 큐는 1:1 상황에서 한 서비스가 다른 서비스에게 동작을 지시할 때 유용하며, 스트림은 다대다 상황에서 유리하다.

## 레디스 메시지 브로커
- 방행자가 특정한 채널에 데이터를 전송하면 이 채널을 듣고 있는 모든 소비자에게 데이터가 전달된다.
- 모든 데이터는 한 번 채널 전체에 전파된 뒤 삭제하는 **일회성** 특징을 가지며, **메시지가 잘 전달되었는지 여부를 저장하지 않는다.**
- **fire-and-forget** 패턴(작업의 완료나 결과에 대한 처리가 필요하지 않는 간단한 알림 기능)에 적합하다.
- 레디스 **list 자료 구조는 메시징 큐**로 사용하기 알맞다. 푸시와 팝이 가능하며 list에 데이터가 있는지 없는지 확인할 필요 없이 새로운 데이터가 들어올 때 읽으면 되기 때문이다.
- **레디스 stream**을 사용하면 stream 플랫폼으로 사용할 수 있다. 아파치 카프카 시스템에서 영감을 받아 만든 자료구조로 **데이터를 계속해서 추가하는 방식**으로 저장한다. **소비자와 소비자 그룹이라는 개념을 이용하면 stream에 저장되는 메시지를 실시간으로 리스닝하며 소비할 수 있으며 저장된 데이터를 시간대별로 검색**하는 것도 가능하다.

# 레디스 pub/sub
- 아주 가벼운 pub/sub 기능 제공한다. 레디스 모든 노드에 접근할 수 있는 모든 클라이언트는 발행자와 구독자가 될 수 있다.
- 발행자는 메시지를 채널로 보낼 수 있을 뿐, 어떤 구독자가 메시지를 읽어가는지, 정상적으로 모든 구독자에게 메시지가 전달됐는지 확인할 수 없다. 구독자 또한 메시지를 받을 수 있지만 해당 메시지가 언제 발행자에 의해 생성됐는지 등의 메타데이터는 알 수 없다.
- 한 번 전파된 데이터는 레디스에 저장되지 않으며, 단순히 메시지 통로 역할만 한다.
- 정합성이 중요한 데이터라면, 애플리케이션 레벨에서 메시지 송수신과 관련한 로직을 추가해야 한다.
  
## 1. 발행(publish)
- 메시지가 전파된 후에는 메시지를 수신한 구독자의 수가 반환된다.
```redis
127.0.0.1:6379> publish event1 "hello event1"
(integer) 1
127.0.0.1:6379> publish event2 "hello event2"
(integer) 1
```

## 2. 구독(subscribe)
- 클라이언트가 구독자로ㄷ동작할 때에는 새로운 채널을 구독할 수 있지만, pub/sub과 관련되지 않은 다른 커맨드를 수행할 수 없다. (subscribe, ssubscribe, sunsubscribe, psubscribe, unsubscribe, ping, reset, quit)
- psubscribe: 일치하는 패턴에 해당하는 채널을 한 번에 구독할 수 있으며, glob-style을 지원한다.
```redis
127.0.0.1:6379> subscribe event1 event2
1) "subscribe"
2) "event1"
3) (integer) 1
4) "subscribe"
5) "event2"
6) (integer) 2
7) "message"
8) "event1"
9) "hello event1"
10) "message"
11) "event2"
12) "hello event2"

127.0.0.1:6379> psubscribe event*
1) "psubscribe"
2) "event*"
3) (integer) 1
1) "pmessage"
2) "event*"
3) "event1"
4) "hello event1"
1) "pmessage"
2) "event*"
3) "event2"
4) "hello event2"
```

## 3. 클러스터 구조에서 pub/sub
- 메시지를 발행하면 해당 메시지는 클러스터에 속한 모든 노드에 자동으로 전달된다. 따라서 레디스 클러스터의 아무 노드에 연결해 subscribe 커맨드를 사용하면 데이터를 수신할 수 있다.
- 하나의 노드에서 메시지를 발행하면 메시지는 모든 노드에 전파된다. 굉장히 간단하고 명료하지만, 사실 클러스터의 주요 목적을 고려하면 비효율적인 방식으로 여겨질 수 있다. 클러스터는 대규모 서비스에서 데이터를 분산해서 저장하고 처리하기 위해 도입된 것으로 핵심 목표와 부합되지 않는 것으로 보인다.

## 4. shared pub/sub
- 레디스 7.0부터 위의 비효율을 해결하기 위해 도입되었다. 각 채널은 슬롯에 매핑딘다.
- 클러스터에서 키가 슬롯에 할당되는 것과 동일한 방식으로 채널이 할당되며, 같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지를 전파한다.
- spublish 커맨드로 발행된 메시지는 모든 노드에 전파되지 않으며, 노드의 복제복에만 전달된다.
- ssubscribe 커맨드도 마찬가지로 특정한 서버에서만 수행될 수 있다.
- 클러스터 구조에서 pub/sub되는 메시지는 모든 노드로 전파되지 않기에 불필요한 복제를 줄일 수 있다는 장점이 있다.

# 레디스 list 메시징 큐
- tail과 head에서 데이터를 넣고 뺄 수 있는 LPUSH, POP, RPUSH, RPOP 커맨드가 존재하기에 애플리케이션 특성에 맞는 메시징 큐를 직접 구현할 수 있다는 장점이 있다.

## 1. list EX
- RPUSHX는 데이터를 저장하고자 하는 list가 이미 존재할 때에만 아이템을 추가하는 커맨드다. 이 커맨드를 이용하면 이미 캐시된 타임라임에만 데이터를 추가할 수 있다. (자주 들어오지 않는 유저에 대해선 캐시 데이터를 관리하지 않음)
- 사용자의 캐시가 이미 존재하는지 유무를 애플리케이션에서 확인하지 않고 레디스에서 처리하기에 성능이 향상된다.

## 2. list blocking
- 이벤트 기반 구조에서는 이벤트 루프를 돌며 신규로 처리할 이벤트가 있는지 확인한다. 이벤트 루프는 이벤트 큐에 새 이벤트가 있는지 확인하며, 새로운 이벤트가 없을 경우 정해진 시간(polling interval)동안 대기한 뒤 다시 이벤트 큐에 데이터가 있는지 확인하는 과정을 반복한다. 
- 폴링 프로세스가 진행되는 동안 리소스가 불필요하게 소모되고, 이벤트가 큐에 들어왔을 수도 있지만 폴링 인터벌로 대기하고 확인하기 때문에 이벤트가 즉시 처리될 수 없다는 단점이 있다. 이때 리스트 블로킹 기능을 이용하면 이런 문제를 해결할 수 있다.
- BRPOP과 BLPOP은 BROP과 LPOP에 블로킹을 추가한 커맨드다. 클라이언트가 BLPOP을 사용해 데이터를 요청하면 list에 데이터가 있을 때 즉시 반환한다. 데이터가 없는 경우엔 데이터가 들어올 때까지 기다린 후에 값을 반환하거나 타임 아웃시간만큼 대기한 후 null을 반환한다.
- BRPOP은 2개의 데이터를 반환한다. 첫 번째는 팝된 리스트의 키 값을 반환하고, 두 번째에 반환된 데이터의 값을 반환한다. 이렇게 설계된 이유는 동시에 여러 개의 리스트에서 대기할 수 있게 하기 위해서다.

## 3. list 원형 큐
- BPOPLPUSH 커맨드를 사용하면 간편하게 원형 큐를 사용할 수 있다.
```redis
127.0.0.1:6379> LRANGE clist 0 -1
1) "C"
2) "B"
3) "A"

127.0.0.1:6379> RPOPLPUSH clist clist
"A"

127.0.0.1:6379> LRANGE clist 0 -1
1) "A"
2) "C"
3) "B"
```
# Stream
- 레디스 5.0에서 새로 추가된 자료 구조, 대용량 대규모 메시징 데이터를 빠르게 처리할 수 있도록 설계
- 데이터를 계속 추가하는 방식으로 저장되는 append-only 자료 구조
- stream을 대량의 데이터를 효율적으로 처리하는 플랫폼으로 활용
- 데이터 엔지니어들은 stream을 여러 생산자가 생성한 데이터를 다양한 소비자가 처리할 수 있게 지원하는 데이터 저장소 및 중간 큐잉 스트림

## 1. 스트림
- 스트림이란 연속적인 데이터의 흐름, 일정한 데이터 조각의 연속을 의미
- 파일 하나는 유한하지만 이를 읽어올 때 애플리케이션은 단어 단위 또는 줄 단위로 잘게 쪼래서 처리하기 때문에 프로그램은 바이트 스트림을 처리하는 것으로 생각할 수 있다.
- 끝이 정해지지 않고 계속 불규칙한 데이터를 연속으로 반복처리 할 때도 스트림으로 처리한다고 볼 수 있다. (채팅 프로그램 JSON 파일 스트리밍)
- 이벤트를 스트리밍 방식으로 처리하는 것은 편리하지만, 직접 이러한 스트리밍 플랫폼을 구축하는 것은 어려울 수 있다. 카프카나 레디스는 스트림 데이터 처리를 더 쉽고 정확하게 수행할 수 있다.

## 2. 데이터 저장

### 1) 메시지 저장과 식별
- 카프카에서 스트림 데이터는 토픽이라는 개념에 저장된다. 토픽은 각각의 분리된 스트림을 뜻하며, 같은 데이터를 관리하는 하나의 그룹을 의미한다.
- 레디스에서는 하나의 stream 자료 구조가 하나의 stream을 의미한다. stream 또한 하나의 키에 연결된 자료 구조이다.
- 카프카에서 각 메시지는 0부터 시작해 증가하는 시퀀스 넘버로 식별할 수 있는데, 이는 토픽 내의 파티션 안에서만 유니크하게 증가하기 때문에 토픽이 1개 이상의 파티션을 갖는다면 유니크하게 식별되지 않는다.
- 레디스 stream에서 각 메시진느 시간과 관련한 유니크한 값을 가지며, 중복되지 않는다.

### 2) 스트림 생성과 데이터 입력
- 카프카에서 각 스트림은 토픽이라는 이름으로 관리된다. 생성자는 데이터를 토픽에 푸시하며, 소비자는 토픽에서 데이터를 읽어간다. 카프카에서는 데이터를 저장하기 위해 토픽을 먼저 생성한 뒤, 프로듀서를 이용해 메시지를 보낼 수 있다.
- 레디스에서 따로 stream을 생성하는 과정은 필요치 않으며, XADD 커맨드를 이용해 새로운 이름의 stream 데이터를 저장하면 저장과 동시에 stream 자료구조가 생성된다.
```
127.0.0.1:6379> XADD Email * subject "first" body "hello?"
"1722173856466-0"
```
- Email 이라는 이름의 stream이 생성된다. 기존에 같은 이름의 키가 존재했다면, 이 커맨드는 기존 stream에 새로운 메시지를 추가하며 존재하지 않았을 때에는 Email이라는 이름의 키를 가진 새로운 Stream 자료 구조를 생성한다.
- \*필드는 저장되는 데이터 ID를 의미하며, 레디스에서 자동 생성되는 타임스탬프 ID를 사용하겠다는 것을 의미한다.
- XADD 커맨드로 저장했을 때 반환되는 값이 바로 저장되는 데이터의 ID이다. 
- 만약 자동으로 생성되는 ID가 아니라 서비스에서 기존에 사용하던 ID를 이용해 메시지를 구분하고 싶다면 \*필드가 아니라 직접 아이디 값을 지정하면 된다.
```redis
127.0.0.1:6379> XADD mystream 0-1 "hello" "world"
"0-1"
```
### 3) 데이터 조회
- 카프카에서 소비자는 특정 토픽을 실시간으로 리스닝하며, 새롭게 토픽에 저장되는 메시지를 전달받을 수 있다.
- 기본적으로 리스닝을 시작한 시점부터 토픽에 새로 저장되는 메시지를 반환하도록 동작
- --from-beginning 옵션을 이용하면 카프카에 저장돼 있는 모든 데이터를 처음부터 읽겠다는 뜻이다.
- 소비자는 더 이상 토픽에서 읽어올 데이터가 없으면 새로운 이베튼가 토픽에 들어올 때까지 계속 토픽을 리스닝하면서 기다린다.
- 레디스 stream에서는 두 가지 방식으로 읽을 수 있다. 첫 번째는 카프카처럼 실시간으로 처리되는 데이터를 리스닝하는 것이고, 두 번째는 ID를 이용해 필요한 데이터를 검색하는 방식이다.
```redis
// 실시간 리스닝
XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
```
- XREAD 커맨드를 이용하면 실시간으로 stream에 저장되는 데이터를 읽을 수 있다.
```redis
127.0.0.1:6379> XREAD BLOCK 0 STREAMS EMAIL 0
```
- BLOCK 0은 stream에서 가져올 데이터가 없더라도 연결을 끊지 않고 계속 stream listening 하라는 의미다.
- STREAMS EMAIL 0은 EMAIL이라는 stream에 저장된 데이터 중 ID가 0보다 큰 값을 읽어오라는 의미
```redis
XRANGE key start end [COUNT count]
XREVRANGE key end start [COUNT count]
```
- XRANGE 커맨드를 이용하면, ID를 이용해 원하는 시간대의 데이터를 조회할 수 있다.
- Stream에 저장된 ID 중 가장 작은 ID 값을 지정하고 싶을 때는 -, 제일 마지막 ID 값을 지정하고 싶을 때는 +기호를 사용한다. XREVRANGE는 역순으로 데이터를 조회한다.
```redis
127.0.0.1:6379> XRANGE Email - +
1) 1) "1722173856466-0"
   2) 1) "subject"
      2) "first"
      3) "body"
      4) "hello?"
```
- XREAD는 기존 데이터를 모두 반환한 뒤 신규 데이터도 반환하지만, XRANGE 커맨드는 수행하는 시점에 모든 데이터를 반환한 뒤 종료된다는 차이점이 있다.

### 4) 소비자와 소비자 그룹
- 팬아웃이란 같은 데이터를 여러 소비자에게 전달하는 것이다.
- 레디스 Stream에서도 XREAD 커맨드를 여러 소비자가 수행한다면 팬아웃이 가능하다. 
- 같은 데이터를 여러 소비자가 나눠서 가져가기 위해서는? 같은 역할을 하는 여러 개의 소비자를 이용해 메시지를 병렬 처리하여 서비스 처리 성능을 높일 수 있다.
- Stream을 이용해 이벤트 데이터를 처리하는 상황에서 이벤트의 처리 성능을 높이기 위해 여러 소비자를 이용해 한 번에 여러 이벤트를 병렬적으로 처리되도록 구성할 수 있다.
  - 카프카에서 유니크 키는 파티션 내에서만 보장되기 때문에 소비자가 여러 파티션에서 토픽을 읽어갈 때에는 데이터의 순서를 보장할 수 없다. 카프카에서 메시지 순서가 보장되려면 소비자 그룹을 사용해야 한다.
  - 레디스 Stream에서는 데이터가 저장될 때마다 고유한 ID를 부여받아 순서대로 저장된다. 따라서 소비자에게 데이터가 전달될 때, 그 순서는 항상 보장된다.
- 레디스 Stream에서 소비자 개념은 카프카와 다르다. 메시지가 전달되는 순서를 신경 스지 않아도 되기 때문이다. 소비자 그룹 내 한 소비자는 다른 소비자가 아직 읽지 않은 데이터만 가져간다.
```redis
127.0.0.1:6379> XGROUP CREATE Email EmailServiceGroup $ 
OK
```
- Email Stream을 읽어가는 EmailServiceGroup이라는 소비자 그룹을 생성하며, $는 현재 시점 이후의 데이터부터 리스닝하겠다는 의미이다.
```redis
127.0.0.1:6379> XADD Email * field1 value1
"1722335146074-0"

127.0.0.1:6379> XREADGROUP GROUP EmailServiceGroup emailService1 COUNT 1 STREAMS Email >
1) 1) "Email"
   2) 1) 1) "1722335146074-0"
         2) 1) "field1"
            2) "value1"
```
- 카프카와는 다르게 레디스 Stream에서 각 소비자는 COUNT 커맨드를 이용해 소비할 메시지 개수를 직접 지정할 수 있다.
- STREAM EMAIL > 이란 Email 이라는 이름의 stream에서 다른 소비자에게 전달되지 않았던ㄷ새로운 메시지를 전달하라는 것을 의미한다. 만약 0 또는 다른 숫자 ID를 입력할 경우 새로운 메시지를 확인하는 것이 아닌, 입력한 ID보다 큰 ID 중 대기 list에 속하던 메시지를 반환한다.
- XREAD GROUP을 사용하면 여러 stream 데이터를 동시에 읽어올 수 있지만, 이를 가능하게 하기 위해선 stream에 동일한 이름을 가진 소비자 그룹을 먼저 생성한다.
- XREADGROUP을 사용하 stream 데이터를 읽어올 때, 읽어오는 동작 자체가 소비자 그룹에 영향을 미치기 때문에 일종의 쓰기 커맨드로 생각해야 한다. 이 커맨드는 마스터에서만 사용할 수 있다.
- 레디스 stream에서 소비자 그룹은 stream의 상태를 나타내는 개념으로 간주한다. 보류된 메시지의 관리 방식과 새로운 메시지를 요청하는 소비자는 매번 새로운 메시지의 ID를 할당받을 수 있는 방법이다. 
- 부하 분산의 관점에서 카프카는 파티ㄹ이라는 개념을 이용한다면, 레디스의 stream은 파티션이라는 분할 없이도 소비자 그룹이라는 개념을 이용해 여러 소비자에게 stream 데이터를 분산시킬 수 있다는 특징을 갖고 있다.
- Stream과 소비자 그룹은 독립적으로 동작할 수 있다. Email이라는 stream 메시지를 읽어가기 위한 그룹은 다수 존재할 수 있으며, 각각 독립적으로 동작한다. 
```redis
127.0.0.1:6379> XGROUP CREATE Email BIGroup 0 MKSTREAM
OK

127.0.0.1:6379> XGROUP CREATE Push BIGroup 0 MKSTREAM
OK

127.0.0.1:6379> XADD Email * field1 value1
"1722335715793-0"

127.0.0.1:6379> XADD Push * field2 value2
"1722335725550-0"

127.0.0.1:6379> XREADGROUP GROUP BIGroup BI1 COUNT 2 STREAMS Email Push > >
1) 1) "Email"
   2) 1) 1) "1722173856466-0"
         2) 1) "subject"
            2) "first"
            3) "body"
            4) "hello?"
      2) 1) "1722335146074-0"
         2) 1) "field1"
            2) "value1"
2) 1) "Push"
   2) 1) 1) "1722335725550-0"
         2) 1) "field2"
            2) "value2"
```
- XREADGROUP 커맨드를 이용해서 데이터를 읽으면 BiGroup은 Email과 Push 2개의 stream을 리스닝할 수 있게 된다.
- 소비자 그룹에 전달되는 모든 데이터는 시간 순으로 정렬돼 있으며, stream에 쌓인 메시지는 해당 데이터에 필요한 여러 서비스로 분산돼 읽힐 수 있다.

### 5) ACK와 보류 리스트
- 메시지 브로커는 각 소비자에게 어떤 메시지까지 전달됐고, 전달된 메시지의 처리 유무를 인지하고 있어야 한다.
- 레디스 stream에서는 소비자 그룹에 속한 소비자가 메시지를 읽어가면ㅅ각 소비자별로 읽어간 메시지에 대한 리스트를 새로 생성하며, 마지막으로 읽어간 데이터의 ID로 last_delivered_id 값을 업데이트 한다.
- last_delivered_id 값은 해당 소비자 그룹에 마지막으로 전달한 ID가 무엇인지를 파악해, 동일한 메시지를 중복으로 전달하지 않기 위해 사용한다.
- 레디스 stream은 소비자별로 보류 리스트(pending list)를 만들고, 어떤 소비자가 어떤 데이터를 읽어갔는지 인식하고 있다. 만약 이메일 서비스 2가 stream에게 데이터가 처리됐다는 뜻의 ACK를 보내면 레디스 stream은 이메일 서비스 2의 보류 리스트에서 ACK를 받은 메시지를 삭제한다. 즉, 보류 리스트를 이용해 소비자가 처리한 데이터를 파악할 수 있다.
```redis
127.0.0.1:6379> XPENDING Email EmailServiceGroup
1) (integer) 1
2) "1722335146074-0"
3) "1722335146074-0"
4) 1) 1) "emailService1"
      2) "1"
```
- 현재 소비자 그룹에서 보류 중인 리스트가 있는지 확인하려면 위의 커맨드를 이용한다. 반횐되는 ㅂ 번쨰 값은 현재 소비자 그룹에서 ACK를 받지 못해 보류 중인 메시지의 개수이며, 두 번째 세 번째 값은 각각 보류 중인 메시지의 ID의 최솟값, 최댓값이다. 그 뒤로는 각 소비ㄹ별로 보류 중인 리스트가 몇 개 있는 지 알려준다.
```redis
127.0.0.1:6379> XACK Email EmailServiceGroup 1722335146074-0
(integer) 1

127.0.0.1:6379> XPENDING Email EmailServiceGroup
1) (integer) 0
2) (nil)
3) (nil)
4) (nil)
```
- XACK를 이용해 데이터가 처리됐음을 알려줄 수 있다.
- 카프카도 레디스 stream과 비슷하게 파티션별 오프셋을 관리한다. 카프카는 내부적으로 __consumer_offsets라는 토픽에 기록하는데, 소비자가 지정된 토픽의 특정 파티션의 메시지를 읽으면 소비자 그룹, 토픽, 파티션 내용이 통합돼 저장된다. 소비자 그룹은 __consumer_offses 토픽에 기록된 정보를 이용해 내부 소비자가 어디까지 읽었는지 추적할 수 있다.
#### Redis stream에서 at most once, at least once, exactly once
- 메시징 시스템에선 다음 세 가지 메시지 보증 전략
- at most once: 메시지를 최소 한 번 보내는 것을 의미
- at least once: 소비자는 받은 메시지를 모두 처리한 뒤 ack를 보냄
- exactly once: 모든 메시지가 무족건 한 번씩 ㄷ송되는 것을 보장

### 6) 메시지 재할당
- 레디스는 소비자에게 장애가 날 경우를 대비해 소비자별 보류 리스트를 유지한다.
- 소비자 서버에 장애가 발생해 복구되지 않는다면, 해당 소비자가 처리하던 보류 중인 메시지들은 다른 소비자가 대신 처리해야 한다. 
- XCLAIM 커맨드를 이용하면 메시지의 소유권을 다른 소비자에게 할당할 수 있다.
- XCLAIM 커맨드를 사용할 때에는 최소 대기 시간(min_idle_time)을 지정해야 한다. 이는 메시지가 보류 상태로 머무른 시간이 최소 대기 시간을 초과한 경우에만 소유권을 변경할 수 있도록하여 같은 메시지가 2개의 다른 소비자에게 중복으로 할당되는 것을 방지한다.

### 7) 메시지 자동 재할당
- 보류 중인 메시지를 확인하고 특정 소비자에게 직접 소유권을 재할당하는ㅂ작업이 자주 발생한다면 XPENDING, XCLAIM 명령어는 번거로울 수 있다.
- XAUTOCLAIM 커맨드는 할당 대기 중인 다음 메시지의 ID를 반환하는 방식으로 동작하기 때문에 반복적 호출이 가능하다.

### 8) 메시지 수동 재할당
- stream 내 각 메시지는 counter라는 값을 각각 가지고 있다. XREADGROUP을 이용해 소비자에게 할당하거나 XCLAIM 커맨드를 이용해 재할당할 경우 1씩 증가한다.
- 메시지가 처리되지 못하고 보류될 경우 위와 같은 프로세스에 의해 새로운 소비자에게 다시 할당돼 처리된다.
- 하지만 만약 메시지에 문제가 있어 처리되지 못할 경우 counter값이 계속 증가하게 된다. 따라서 counter가 특정 값에 도달하면 이 메시지를 특수한 다른 stream으로 보내, 관리자가 추후에 처리하도록 하는 것이 효율적일 수 있다. 이런 메시지를 dead letter라고 한다.
- XINFO 커맨드로 stream의 여러 상태를 확인한다. (XINFO help)
