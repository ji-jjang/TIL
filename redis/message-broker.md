# 메시징 큐와 이벤트 스트림
- 최근 서비스 아키텍처는 느슨하고 적절한 연결, 가용성 및 성능을 위한 비동기 통신 -> 어딘가에 메시지를 쌓아둔 뒤 나중에 처리할 수 있는 채널이 필요하고, 이것이 메시지 브로커의 핵심 역할이다.
- 메시지 브로커는 크게 메시징 큐와 이벤트 스트림이라는 두 가지 형태로 나눌 수 있다.
- 메시징 큐에서는 주로 데이터를 생성하는 쪽을 생성자(producer), 데이터를 수신하는 쪽을 수신자(consumer)로 지칭한다.
- 이벤트 스트림에서는 주로 데이터를 생성하는 쪽을 발행자(publisher), 데이터를 조회하는 쪽을 구독자(subscriber)로 지칭한다.

## 차이점
### 1. 방향성
- 메시징 큐의 생산자는 소비자의 큐로 데이터를 직접 푸시한다. 2개의 서비스에 같은 메시지를 보내야 할 때 메시징 큐를 이용한다면 생산자는 2개의 다른 메시징 큐에 각각 데이터를 푸시해야 한다. 반면 스트림을 이용한다면 특정 저장소에 하나의 메시지를 보낼 수 있고, 소비자들은 스트림에서 같은 메시지를 받을 수 있기에 메시지를 복제해서 저장하지 않아도 된다.

### 2. 영속성
- 메시징 큐에서는 소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제한다. 이벤트 스트림에서는 구독자가 읽어간 데이터는 바로 삭제되지 않고, 저장소의 설정에 따라 특정 기간 동안 저장될 수 있다. 

### 3. 확장성
- 메시지를 보내는 중에 새로운 소비자를 추가할 때도 메시지 큐를 이용한다면 새롭게 추가된 이후의 이벤트만 확인할 수 있다. 스트림 방식에서는 메시지를 생상할 때 구독자를 지정하지 않고, 스트림에 쌓인 데이터는 일정 기간 동안 지워지지 않기 때문에 새로 추가된 서비스도 스트림에 남아 있는 이전 데이터의 히스토리를 볼 수 있다.
- 메시징 큐는 1:1 상황에서 한 서비스가 다른 서비스에게 동작을 지시할 때 유용하며, 스트림은 다대다 상황에서 유리하다.

## 레디스 메시지 브로커
- 방행자가 특정한 채널에 데이터를 전송하면 이 채널을 듣고 있는 모든 소비자에게 데이터가 전달된다.
- 모든 데이터는 한 번 채널 전체에 전파된 뒤 삭제하는 **일회성** 특징을 가지며, **메시지가 잘 전달되었는지 여부를 저장하지 않는다.**
- **fire-and-forget** 패턴(작업의 완료나 결과에 대한 처리가 필요하지 않는 간단한 알림 기능)에 적합하다.
- 레디스 **list 자료 구조는 메시징 큐**로 사용하기 알맞다. 푸시와 팝이 가능하며 list에 데이터가 있는지 없는지 확인할 필요 없이 새로운 데이터가 들어올 때 읽으면 되기 때문이다.
- **레디스 stream**을 사용하면 stream 플랫폼으로 사용할 수 있다. 아파치 카프카 시스템에서 영감을 받아 만든 자료구조로 **데이터를 계속해서 추가하는 방식**으로 저장한다. **소비자와 소비자 그룹이라는 개념을 이용하면 stream에 저장되는 메시지를 실시간으로 리스닝하며 소비할 수 있으며 저장된 데이터를 시간대별로 검색**하는 것도 가능하다.

# 레디스 pub/sub
- 아주 가벼운 pub/sub 기능 제공한다. 레디스 모든 노드에 접근할 수 있는 모든 클라이언트는 발행자와 구독자가 될 수 있다.
- 
## 1. 발행(publish)

## 2. 구독(subscribe)

## 3. 클러스터 구조에서 pub/sub

## 4. shared pub/sub

# 레디스 list 메시징 큐

## 1. list EX

## 2. list blocking

## 3. list 원형 큐

# Stream

## 1. 레디스 Stream과 아파치 카프카

## 2. 스트림

## 3. 데이터 저장

### 1) 메시지 저장과 식별

### 2) 스트림 생성과 데이터 입력

### 3) 데이터 조회

### 4) 소비자와 소비자 그룹

### 5) ACK와 보류 리스트

### 6) 메시지 재할당

### 7) 메시지 자동 재할당

### 8) 메시지 수동 재할당
