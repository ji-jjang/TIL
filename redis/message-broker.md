# 메시징 큐와 이벤트 스트림
- 최근 서비스 아키텍처는 느슨하고 적절한 연결, 가용성 및 성능을 위한 비동기 통신 -> 어딘가에 메시지를 쌓아둔 뒤 나중에 처리할 수 있는 채널이 필요하고, 이것이 메시지 브로커의 핵심 역할이다.
- 메시지 브로커는 크게 메시징 큐와 이벤트 스트림이라는 두 가지 형태로 나눌 수 있다.
- 메시징 큐에서는 주로 데이터를 생성하는 쪽을 생성자(producer), 데이터를 수신하는 쪽을 수신자(consumer)로 지칭한다.
- 이벤트 스트림에서는 주로 데이터를 생성하는 쪽을 발행자(publisher), 데이터를 조회하는 쪽을 구독자(subscriber)로 지칭한다.

## 차이점
### 1. 방향성
- 메시징 큐의 생산자는 소비자의 큐로 데이터를 직접 푸시한다. 2개의 서비스에 같은 메시지를 보내야 할 때 메시징 큐를 이용한다면 생산자는 2개의 다른 메시징 큐에 각각 데이터를 푸시해야 한다. 반면 스트림을 이용한다면 특정 저장소에 하나의 메시지를 보낼 수 있고, 소비자들은 스트림에서 같은 메시지를 받을 수 있기에 메시지를 복제해서 저장하지 않아도 된다.

### 2. 영속성
- 메시징 큐에서는 소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제한다. 이벤트 스트림에서는 구독자가 읽어간 데이터는 바로 삭제되지 않고, 저장소의 설정에 따라 특정 기간 동안 저장될 수 있다. 

### 3. 확장성
- 메시지를 보내는 중에 새로운 소비자를 추가할 때도 메시지 큐를 이용한다면 새롭게 추가된 이후의 이벤트만 확인할 수 있다. 스트림 방식에서는 메시지를 생상할 때 구독자를 지정하지 않고, 스트림에 쌓인 데이터는 일정 기간 동안 지워지지 않기 때문에 새로 추가된 서비스도 스트림에 남아 있는 이전 데이터의 히스토리를 볼 수 있다.
- 메시징 큐는 1:1 상황에서 한 서비스가 다른 서비스에게 동작을 지시할 때 유용하며, 스트림은 다대다 상황에서 유리하다.

## 레디스 메시지 브로커
- 방행자가 특정한 채널에 데이터를 전송하면 이 채널을 듣고 있는 모든 소비자에게 데이터가 전달된다.
- 모든 데이터는 한 번 채널 전체에 전파된 뒤 삭제하는 **일회성** 특징을 가지며, **메시지가 잘 전달되었는지 여부를 저장하지 않는다.**
- **fire-and-forget** 패턴(작업의 완료나 결과에 대한 처리가 필요하지 않는 간단한 알림 기능)에 적합하다.
- 레디스 **list 자료 구조는 메시징 큐**로 사용하기 알맞다. 푸시와 팝이 가능하며 list에 데이터가 있는지 없는지 확인할 필요 없이 새로운 데이터가 들어올 때 읽으면 되기 때문이다.
- **레디스 stream**을 사용하면 stream 플랫폼으로 사용할 수 있다. 아파치 카프카 시스템에서 영감을 받아 만든 자료구조로 **데이터를 계속해서 추가하는 방식**으로 저장한다. **소비자와 소비자 그룹이라는 개념을 이용하면 stream에 저장되는 메시지를 실시간으로 리스닝하며 소비할 수 있으며 저장된 데이터를 시간대별로 검색**하는 것도 가능하다.

# 레디스 pub/sub
- 아주 가벼운 pub/sub 기능 제공한다. 레디스 모든 노드에 접근할 수 있는 모든 클라이언트는 발행자와 구독자가 될 수 있다.
- 발행자는 메시지를 채널로 보낼 수 있을 뿐, 어떤 구독자가 메시지를 읽어가는지, 정상적으로 모든 구독자에게 메시지가 전달됐는지 확인할 수 없다. 구독자 또한 메시지를 받을 수 있지만 해당 메시지가 언제 발행자에 의해 생성됐는지 등의 메타데이터는 알 수 없다.
- 한 번 전파된 데이터는 레디스에 저장되지 않으며, 단순히 메시지 통로 역할만 한다.
- 정합성이 중요한 데이터라면, 애플리케이션 레벨에서 메시지 송수신과 관련한 로직을 추가해야 한다.
  
## 1. 발행(publish)
- 메시지가 전파된 후에는 메시지를 수신한 구독자의 수가 반환된다.
```redis
127.0.0.1:6379> publish event1 "hello event1"
(integer) 1
127.0.0.1:6379> publish event2 "hello event2"
(integer) 1
```

## 2. 구독(subscribe)
- 클라이언트가 구독자로ㄷ동작할 때에는 새로운 채널을 구독할 수 있지만, pub/sub과 관련되지 않은 다른 커맨드를 수행할 수 없다. (subscribe, ssubscribe, sunsubscribe, psubscribe, unsubscribe, ping, reset, quit)
- psubscribe: 일치하는 패턴에 해당하는 채널을 한 번에 구독할 수 있으며, glob-style을 지원한다.
```redis
127.0.0.1:6379> subscribe event1 event2
1) "subscribe"
2) "event1"
3) (integer) 1
4) "subscribe"
5) "event2"
6) (integer) 2
7) "message"
8) "event1"
9) "hello event1"
10) "message"
11) "event2"
12) "hello event2"

127.0.0.1:6379> psubscribe event*
1) "psubscribe"
2) "event*"
3) (integer) 1
1) "pmessage"
2) "event*"
3) "event1"
4) "hello event1"
1) "pmessage"
2) "event*"
3) "event2"
4) "hello event2"
```

## 3. 클러스터 구조에서 pub/sub
- 메시지를 발행하면 해당 메시지는 클러스터에 속한 모든 노드에 자동으로 전달된다. 따라서 레디스 클러스터의 아무 노드에 연결해 subscribe 커맨드를 사용하면 데이터를 수신할 수 있다.
- 하나의 노드에서 메시지를 발행하면 메시지는 모든 노드에 전파된다. 굉장히 간단하고 명료하지만, 사실 클러스터의 주요 목적을 고려하면 비효율적인 방식으로 여겨질 수 있다. 클러스터는 대규모 서비스에서 데이터를 분산해서 저장하고 처리하기 위해 도입된 것으로 핵심 목표와 부합되지 않는 것으로 보인다.

## 4. shared pub/sub
- 레디스 7.0부터 위의 비효율을 해결하기 위해 도입되었다. 각 채널은 슬롯에 매핑딘다.
- 클러스터에서 키가 슬롯에 할당되는 것과 동일한 방식으로 채널이 할당되며, 같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지를 전파한다.
- spublish 커맨드로 발행된 메시지는 모든 노드에 전파되지 않으며, 노드의 복제복에만 전달된다.
- ssubscribe 커맨드도 마찬가지로 특정한 서버에서만 수행될 수 있다.
- 클러스터 구조에서 pub/sub되는 메시지는 모든 노드로 전파되지 않기에 불필요한 복제를 줄일 수 있다는 장점이 있다.

# 레디스 list 메시징 큐
- tail과 head에서 데이터를 넣고 뺄 수 있는 LPUSH, POP, RPUSH, RPOP 커맨드가 존재하기에 애플리케이션 특성에 맞는 메시징 큐를 직접 구현할 수 있다는 장점이 있다.

## 1. list EX
- RPUSHX는 데이터를 저장하고자 하는 list가 이미 존재할 때에만 아이템을 추가하는 커맨드다. 이 커맨드를 이용하면 이미 캐시된 타임라임에만 데이터를 추가할 수 있다. (자주 들어오지 않는 유저에 대해선 캐시 데이터를 관리하지 않음)
- 사용자의 캐시가 이미 존재하는지 유무를 애플리케이션에서 확인하지 않고 레디스에서 처리하기에 성능이 향상된다.

## 2. list blocking
- 이벤트 기반 구조에서는 이벤트 루프를 돌며 신규로 처리할 이벤트가 있는지 확인한다. 이벤트 루프는 이벤트 큐에 새 이벤트가 있는지 확인하며, 새로운 이벤트가 없을 경우 정해진 시간(polling interval)동안 대기한 뒤 다시 이벤트 큐에 데이터가 있는지 확인하는 과정을 반복한다. 
- 폴링 프로세스가 진행되는 동안 리소스가 불필요하게 소모되고, 이벤트가 큐에 들어왔을 수도 있지만 폴링 인터벌로 대기하고 확인하기 때문에 이벤트가 즉시 처리될 수 없다는 단점이 있다. 이때 리스트 블로킹 기능을 이용하면 이런 문제를 해결할 수 있다.
- BRPOP과 BLPOP은 BROP과 LPOP에 블로킹을 추가한 커맨드다. 클라이언트가 BLPOP을 사용해 데이터를 요청하면 list에 데이터가 있을 때 즉시 반환한다. 데이터가 없는 경우엔 데이터가 들어올 때까지 기다린 후에 값을 반환하거나 타임 아웃시간만큼 대기한 후 null을 반환한다.
- BRPOP은 2개의 데이터를 반환한다. 첫 번째는 팝된 리스트의 키 값을 반환하고, 두 번째에 반환된 데이터의 값을 반환한다. 이렇게 설계된 이유는 동시에 여러 개의 리스트에서 대기할 수 있게 하기 위해서다.

## 3. list 원형 큐
- BPOPLPUSH 커맨드를 사용하면 간편하게 원형 큐를 사용할 수 있다.
```redis
127.0.0.1:6379> LRANGE clist 0 -1
1) "C"
2) "B"
3) "A"

127.0.0.1:6379> RPOPLPUSH clist clist
"A"

127.0.0.1:6379> LRANGE clist 0 -1
1) "A"
2) "C"
3) "B"
```
# Stream
- 레디스 5.0에서 새로 추가된 자료 구조, 대용량 대규모 메시징 데이터를 빠르게 처리할 수 있도록 설계
- 데이터를 계속 추가하는 방식으로 저장되는 append-only 자료 구조
- stream을 대량의 데이터를 효율적으로 처리하는 플랫폼으로 활용
- 데이터 엔지니어들은 stream을 여러 생산자가 생성한 데이터를 다양한 소비자가 처리할 수 있게 지원하는 데이터 저장소 및 중간 큐잉 스트림

## 1. 스트림
- 스트림이란 연속적인 데이터의 흐름, 일정한 데이터 조각의 연속을 의미
- 파일 하나는 유한하지만 이를 읽어올 때 애플리케이션은 단어 단위 또는 줄 단위로 잘게 쪼래서 처리하기 때문에 프로그램은 바이트 스트림을 처리하는 것으로 생각할 수 있다.
- 끝이 정해지지 않고 계속 불규칙한 데이터를 연속으로 반복처리 할 때도 스트림으로 처리한다고 볼 수 있다. (채팅 프로그램 JSON 파일 스트리밍)
- 이벤트를 스트리밍 방식으로 처리하는 것은 편리하지만, 직접 이러한 스트리밍 플랫폼을 구축하는 것은 어려울 수 있다. 카프카나 레디스는 스트림 데이터 처리를 더 쉽고 정확하게 수행할 수 있다.

## 2. 데이터 저장

### 1) 메시지 저장과 식별
- 카프카에서 스트림 데이터는 토픽이라는 개념에 저장된다. 토픽은 각각의 분리된 스트림을 뜻하며, 같은 데이터를 관리하는 하나의 그룹을 의미한다.
- 레디스에서는 하나의 stream 자료 구조가 하나의 stream을 의미한다. stream 또한 하나의 키에 연결된 자료 구조이다.
- 카프카에서 각 메시지는 0부터 시작해 증가하는 시퀀스 넘버로 식별할 수 있는데, 이는 토픽 내의 파티션 안에서만 유니크하게 증가하기 때문에 토픽이 1개 이상의 파티션을 갖는다면 유니크하게 식별되지 않는다.
- 레디스 stream에서 각 메시진느 시간과 관련한 유니크한 값을 가지며, 중복되지 않는다.

### 2) 스트림 생성과 데이터 입력
- 카프카에서 각 스트림은 토픽이라는 이름으로 관리된다. 생성자는 데이터를 토픽에 푸시하며, 소비자는 토픽에서 데이터를 읽어간다. 카프카에서는 데이터를 저장하기 위해 토픽을 먼저 생성한 뒤, 프로듀서를 이용해 메시지를 보낼 수 있다.
- 레디스에서 따로 stream을 생성하는 과정은 필요치 않으며, XADD 커맨드를 이용해 새로운 이름의 stream 데이터를 저장하면 저장과 동시에 stream 자료구조가 생성된다.
```
127.0.0.1:6379> XADD Email * subject "first" body "hello?"
"1722173856466-0"
```
- Email 이라는 이름의 stream이 생성된다. 기존에 같은 이름의 키가 존재했다면, 이 커맨드는 기존 stream에 새로운 메시지를 추가하며 존재하지 않았을 때에는 Email이라는 이름의 키를 가진 새로운 Stream 자료 구조를 생성한다.
- \*필드는 저장되는 데이터 ID를 의미하며, 레디스에서 자동 생성되는 타임스탬프 ID를 사용하겠다는 것을 의미한다.
- XADD 커맨드로 저장했을 때 반환되는 값이 바로 저장되는 데이터의 ID이다. 
- 만약 자동으로 생성되는 ID가 아니라 서비스에서 기존에 사용하던 ID를 이용해 메시지를 구분하고 싶다면 \*필드가 아니라 직접 아이디 값을 지정하면 된다.
```redis
127.0.0.1:6379> XADD mystream 0-1 "hello" "world"
"0-1"
```
### 3) 데이터 조회
- 카프카에서 소비자는 특정 토픽을 실시간으로 리스닝하며, 새롭게 토픽에 저장되는 메시지를 전달받을 수 있다.
- 기본적으로 리스닝을 시작한 시점부터 토픽에 새로 저장되는 메시지를 반환하도록 동작
- --from-beginning 옵션을 이용하면 카프카에 저장돼 있는 모든 데이터를 처음부터 읽겠다는 뜻이다.
- 소비자는 더 이상 토픽에서 읽어올 데이터가 없으면 새로운 이베튼가 토픽에 들어올 때까지 계속 토픽을 리스닝하면서 기다린다.
- 레디스 stream에서는 두 가지 방식으로 읽을 수 있다. 첫 번째는 카프카처럼 실시간으로 처리되는 데이터를 리스닝하는 것이고, 두 번째는 ID를 이용해 필요한 데이터를 검색하는 방식이다.
```redis
// 실시간 리스닝
XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
```
- XREAD 커맨드를 이용하면 실시간으로 stream에 저장되는 데이터를 읽을 수 있다.
```redis
127.0.0.1:6379> XREAD BLOCK 0 STREAMS EMAIL 0
```
- BLOCK 0은 stream에서 가져올 데이터가 없더라도 연결을 끊지 않고 계속 stream listening 하라는 의미다.
- STREAMS EMAIL 0은 EMAIL이라는 stream에 저장된 데이터 중 ID가 0보다 큰 값을 읽어오라는 의미
```redis
XRANGE key start end [COUNT count]
XREVRANGE key end start [COUNT count]
```
- XRANGE 커맨드를 이용하면, ID를 이용해 원하는 시간대의 데이터를 조회할 수 있다.
- Stream에 저장된 ID 중 가장 작은 ID 값을 지정하고 싶을 때는 -, 제일 마지막 ID 값을 지정하고 싶을 때는 +기호를 사용한다. XREVRANGE는 역순으로 데이터를 조회한다.
```redis
127.0.0.1:6379> XRANGE Email - +
1) 1) "1722173856466-0"
   2) 1) "subject"
      2) "first"
      3) "body"
      4) "hello?"
```
- XREAD는 기존 데이터를 모두 반환한 뒤 신규 데이터도 반환하지만, XRANGE 커맨드는 수행하는 시점에 모든 데이터를 반환한 뒤 종료된다는 차이점이 있다.

### 4) 소비자와 소비자 그룹

### 5) ACK와 보류 리스트

### 6) 메시지 재할당

### 7) 메시지 자동 재할당

### 8) 메시지 수동 재할당
