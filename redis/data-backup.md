
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [레디스 데이터 영구 저장](#레디스-데이터-영구-저장)
  - [RDB 방식 데이터 백업](#rdb-방식-데이터-백업)
    - [1. 특정 조건에 자동으로 RDB 파일 생성](#1-특정-조건에-자동으로-rdb-파일-생성)
    - [2. 수동으로 RDB 파일 생성](#2-수동으로-rdb-파일-생성)
    - [3. 복제를 사용할 경우 자동으로 RDB 파일 생성](#3-복제를-사용할-경우-자동으로-rdb-파일-생성)
  - [AOF 방식 데이터 백업](#aof-방식-데이터-백업)
    - [1. AOF 파일 재구성 방법](#1-aof-파일-재구성-방법)
      - [7 이전 버전에서 AOF 재구성이 실행되는 과정](#7-이전-버전에서-aof-재구성이-실행되는-과정)
      - [7 이후 버전에서 AOF 재구성이 실행되는 과정](#7-이후-버전에서-aof-재구성이-실행되는-과정)
    - [2. 자동 AOF 재구성](#2-자동-aof-재구성)
    - [3. 수동 AOF 재구성](#3-수동-aof-재구성)
    - [4. AOF 타임스탬프](#4-aof-타임스탬프)
    - [5. AOF 파일 복원](#5-aof-파일-복원)
    - [6. AOF파일 안전성](#6-aof파일-안전성)
  - [백업 사용 시 주의점](#백업-사용-시-주의점)

<!-- /code_chunk_output -->


# 레디스 데이터 영구 저장
- **복제는 가용성을 위한 것이며, 백업은 장애 상황에서 데이터 복구를 위해 필요**
- 레디스를 캐시가 아닌 영구 저장소와 같은 용도로 사용한다면 디스크에 주기적으로 백업하는 것이 안전. 레디스에서는 RDB, AOF 두 가지 백업 방식을 지원
- **AOF(Append Only File)**: 레디스 인스턴스가 처리한 모든 쓰기 작업을 차례대로 기록, 복원 시에는 파일을 다시 읽어가며 데이터 세트 재구성
- ***RDB(Redis Database)**: 일정 시점에 메모리에 저장된 데이터 전체를 저장(snapshot)
```redis
> SET key1 a
OK 

> SET key1 apple
OK

> SET key2 b
OK

> DEL key2
(integer) 1
```
- AOF의 경우 레디스 프로토콜 형태로 저장되며 명령어를 차례로 기록. RDB는 key1 -> apple 처럼 스냅샷 형태로 바이너리로 저장
- RDB 파일의 경우 시점 단위로 여러 백업본을 저장할 수 있고 AOF 파일보다 복원이 빠름. 하지만, 특정 시점으로 복구는 불가능. AOF는 RDB 파일보다 크기가 크고 주기적으로 압축해 작성해야 하지만, 원하는 시점으로 복구
- 하나의 인스턴스에서 RDB와 AOF 두 가지 옵션을 사용하는 것도 가능, 데이터의 안정성을 원하는 경우 두 가지 백업 방식을 동시에 사용하는 것을 권장
- 레디스에서 데이터를 복원할 수 있는 시점은 서버가 재시작될 때 뿐이며, 레디스 인스턴스의 실행 도중에 데이터 파일을 읽어올 수 있는 방법은 없음
- 레디스 서버는 재시작될 때 AOF 파일이나 RDB 파일이 존재하는지 확인한 뒤 파일이 있을 때 파일을 로드. 레디스는 RDB 파일보다 AOF 파일이 더 내구성이 보장된다고 판단하기에 2개의 파일이 모두 존재할 때 AOF 데이터를 로드

## RDB 방식 데이터 백업
- RDB 파일은ㄷ레디스에서 데이터를 백업하기 위한 가장 단순한 방법
- 원하는 시점에 메모리 자체를 스냅샷 찍듯 저장할 수 있기에 백업에 적합한 파일 형태
- RDB 파일이 저장될 때마다 원격 자정소로 옮겨 2차 백업을 한다면 데이터 센터 장애 등 더 큰 장애에도 대처할 수 있음
- **장애가 발생했을 때 손실 가능성을 최소화해야 하는 서비스에는 RDB 파일을 이용한 백업만 사용하는 것은 적절하지 않음. 사용자가 지정한 시간 단위로 파일이 저장되기에 저장 시점부터 장애가 발생한 직전까지의 데이터는 손실**
- RDB 파일을 생성하는 방법
  - 설정 파일에서 특정 조건에 파일이 자동으로 저장되도록 지정
  - 사용자가 원하는 시점에 커맨드를 이용해 수동으로 파일 생성
  - 복제 기능을 사용한다면 레디스는 자동으로 RDB 파일 생성
### 1. 특정 조건에 자동으로 RDB 파일 생성
```redis
save <기간(초)> <기간 내 변경된 키의 개수>
dbfilename <RDB 파일 이름>
dir <RDB 파일이 저장될 경로>
```
- 레디스 설정 파일에서 save 옵션을 사용해 원하는 조건에 RDB 파일을 저장하도록 설정
- 일정한 기간 동안 변경된 키의 개수가 조건에 맞을 때 레디스 서버는 자동으로 RDB 파일을 저장
```redis
save 900 1 // 900초 동안 1개 이상의 키가 변경된 경우
save 300 10 // 300초 동안 10개 이상의 키가 변경된 경우
save 60 10000 // 60초 동안 10000개 이상의 키가 변경된 경우
```
- 만약 RDB 파일을 저장하고 싶지 않다면 `save ""`와 같이 빈 문자열로 설정해 옵션을 비활성화
- 이미 레디스가 실행 중인 상태에서는 CONFIG SET 커맨드를 이용해 save 파라미터를 ""로 초기화
```redis
127.0.0.1:6379> CONFIG GET save
1) "save"
2) "3600 1 300 100 60 10000"

127.0.0.1:6379> CONFIG SET save ""
OK

127.0.0.1:6379> CONFIG GET save
1) "save"
2) ""

127.0.0.1:6379> CONFIG REWRITE
(error) ERR The server is running without a config file
```
- 실행 중인 레디스 인스턴스에서 파라미터를 수정할 때에는 redis-cli에서 직접 CONFIG SET 커맨드로 설정을 변경한 뒤, CONFIG REWRITE 커맨드를 이용해 설정 파일을 재작성하는 과정
### 2. 수동으로 RDB 파일 생성
- SAVE, BGSAVE 커맨드를 이용하면 원하는 시점에 직접 RDB 파일을 생성. 두 커맨드 모두 실행 시점의 메모리 스냅숏을 생성하는 커맨드이지만 동작하는 방식에 차이. SAVE는 동기 방식으로 파일을 저장하므로 일반적인 운영 환경에서는 사용하지 않는 것이 좋음
- BGSAVE는 fork를 호출해 자식 프로세스를 생성하며 생성된 자식 프로세스가 백그라운드에서 RDB 파일을 생성한 뒤 종료. 레디스를 이용하는 다른 클라이언트는 원래 부모 프로세스에서 처리되기에 파일 저장에 영향을 받지 않음. 만약, 이미 백그라운드로 데이터가 저장되고 있을 때 이 커맨드를 수행하면 에러를 반환. 이때, SCHEDULE 옵션을 사용하면 기존에 진행 중이던 백업이 완료되었을 때 다시 BGSAVE를 실행
- RDB 파일이 정상적으로 저장되었는지 LASTSAVE 커맨드로 확인

### 3. 복제를 사용할 경우 자동으로 RDB 파일 생성
- REPLICAOF 커맨드를 이용해 복제를 요청하면 마스터 노드에서는 RDB 파일을 새로 생성해 복제본에 전달. 혹은 이미 복제 연결이 돼 있는 상태에서 네트워크 등의 이슈로 인해 일정 시간 이상 복제가 끊어졌다가 복구된 경우 복제 재연결이 발생하며, 이럴 경우에도 마스터 노드는 복제본으로 RDB 파일을 전송. 즉, 마스터에서는 언제든지 RDB 파일을 재생성

## AOF 방식 데이터 백업
- AOF는 레디스 인스턴스에서 수행된 모든 쓰기 작업 로그를 차례로 기록
- 실수로 FLUSHALL 커맨드로 데이터를 모두 날려버려도, AOF 파일을 직접 열어 FLUSHALL 커맨드만 삭제한 뒤 레디스를 재시작한다면 커맨드를 실행하기 직전까지 데이터를 모두 복구
- 설정 파일에서 appendonly 옵션을 yes로 지정하면, AOF 파일에 주기적으로 데이터가 저장
```redis
appendonly yes
appendfilename "appendonly.aof"
appenddirname "appendonlydir"
```
- 데이터는 레디스 프로토콜(RESP) 형식으로 저장. 사용자가 실행한 커맨드를 그대로 저장하지 않음. (BRPOP -> BPOP, AOF 파일에서 블로킹 기능을 명시할 필요 없기 때문, 부동소주점도 아키텍처에 따라 다르므로 증분 후의 값을 직접 SET하는 커맨드로 변경되어 저장)

### 1. AOF 파일 재구성 방법
- AOF 파일을 이용한 백업 기능을 안정적으로 사용하려면 점점 커지는 파일을 주기적으로 압축시키는 재구성 작업이 필요
- 압축, 재구성은 기존 디스크에 저장됐던 AOF 파일을 사용하는 것이 아니라 레디스 메모리에 있는 데이터를 읽어와서 새로운 파일로 저장하는 형태로 동작
- aof-use-rdb-preamble를 yes로 no로 변경하지 않았다면, RDB파일 형태로 저장
- 파일을 재구성할 때 fork를 이용해 자식 프로세스를 생성하며, 이 자식 프로세스가 AOF 파일을 재구성해 저장

#### 7 이전 버전에서 AOF 재구성이 실행되는 과정
1. 레디스 fork를 이용해 자식 프로세스 생성, 생성된 자식 프로세스는 레디스 메모리 데이터를 읽어와 신규로 생성한 임시 파일에 저장
2. 백그라운드로 이전 과정이 진행되는 동안 레디스 메모리의 데이터가 변경된 내역은 기존 AOF 파일과 인메모리 버퍼에 동시에 저장
3. 1의 AOF 재구성 과정이 끝나면 인메모리 버퍼에 저장된 내용을 (1)의 임시 파일 마지막에 추가
4. 생성된 임시 파일로 기존 AOF 파일을 덮어 씌움
- 이때, 2의 과정에서 RDB 파일이 저장되는 동안 데이터가 변경된 동일한 로그가 AOF 파일과 인메모리 버퍼에 이중으로 저장. 또한 하나의 AOF 파일 내 바이너리 형태와 RESP 텍스트 형태의 데이터가 함께 저장돼 수동으로 AOF 파일을 처리할 때 관리가 복잡할 수 있다는 단점이 존재
- 버전 7 이후에는 AOF는 기본이 되는 바이너리 형태의 RDB 파일, 증가하는 RESP의 텍스트 형태의 AOF 파일로 나누어 데이터를 관리. 또한, 현재 레디스가 보고 있는 파일이 어떤 것인지를 나타내는 매니페스트 파일이 추가적으로 도입됐으며 이는 RDB와 AOF 파일이 어떤 것임을 알려줌
  
#### 7 이후 버전에서 AOF 재구성이 실행되는 과정
1. 레디스 fork를 이용해 자식 프로세스 생성. 생성된 자식 프로세스는 레디스 메모리 데이터를 읽어와 신규로 생성한 임시 파일에 저장
2. 백그라운드로 이전 과정이 진행되는 동안 레디스 메모리 데이터가 변경된 내역은 신규 AOF 파일에 저장 
3. 1의 AOF 재구성 과정이 끝나면 임시 매니페스트 파일을 생성한 뒤, 변경된 버전으로 매니페스트 파일 내용을 업데이트
4. 생성된 임시 매니페스트 파일로 기ㅁ 매니페스트 파일을 덮어씌워 이전 버전의 AOF, RDB 파일을 삭제 
- 기존 버전의 2, 3단계의 비효율을 줄여 훨씬 간단한 과정으로 데이터를 저장
- 레디스에서 AOF 파일 재구성 과정은 모두 순차 입출력(sequential I/O)만 사용하기 때문에 디스크에 접근하는 모든 과정이 굉장히 효율적 (랜덤 입출력을 고려하지 않는다는 점은 굉장히 드문 기능)

### 2. 자동 AOF 재구성
```redis
auto-aof-rewrite-percentage 100 // AOF 파일을 다시 쓰기 위한 시점 정하는 옵션
auto-aof-rewrite-min-size 64mb // 재구성된 이후 AOF 파일의 최소 크기 지정 옵션
```

### 3. 수동 AOF 재구성
- BGREWRITEAOF 커맨드를 이용하면 원하는 시점에 직접 AOF 파일을 재구성할 수 있음 (자동으로 재구성할 때와 동일하게 동작)

### 4. AOF 타임스탬프
- 버전 7이상 부터 타임스탬프 남길 수 있음
```redis
aof-timestamp-enabled no
```
- 이를 이용하면 수동으로 AOF 파일을 조작하지 않아도 시스템상에서 시점 복원이 가능
```redis
src/redis-check-aof --truncate-to-timestamp 1669532844 appendonlydir/ appendonly.aof.manifest
```
- 원본 파일이 변경되므로, 작업 파일을 수행하기 이전 AOF 파일을 보호하고 싶다면 위의 옵션을 사용하기 전 원본 파일을 미리 백업

### 5. AOF 파일 복원
- 시점 복원에서 사용한 redis-check-aof 프로그램은 AOF 파일이 손상돼었을 때에도 사용할 수 있음 (의도치 않은 장애 발생 시 AOF 파일 작성 시 레디스 종료되었을 가능성 있음)
- RDB 파일은 정상이나 AOF 파일이 비정상이면 fix 옵션을 사용하여 해결

### 6. AOF파일 안전성
- RDB 방식보다 명령어 단위로 로그를 저장하는 AOF 방식이 더 안전하다. 얼마나 더 안전할까?
- 운영체제 동작: WRITE 시스템 콜을 이용해 애플리케이션에서 파일에 데이터를 저장하겠다하면, 데이터는 커널 영역의 OS 버퍼에 임시로 저장. 커널이 여유 있거나, 최대 지연 시간에 도달하면 커널 버퍼의 데이터를 실제 디스크에 내려씀. FSYNC는 커널 OS 버퍼에 저장된 내용을 실제로 디스크에 내리도록 강제하는 시스템 콜
- 레디스 AOF 파일을 사용할 때 APPENDFSYNC 옵션을 이용하면 FSYNC 호출을 제어
  - APPENDFSYNC no: AOF 데이터를 저장할 때 WRITEㄴ시스템 콜 호출 (쓰기 성능 가장 빠름)
  - APPENDFSYNC always: 항상 write와 FSYNC 시스템 콜 함께 호출 (쓰기 성능 가장 느림)
  - APPENDFSYNC everysec: 데이터를 저장할 때 WRTIE 시스템 콜, 1초에 한 번씩 FSYNC 시스템 콜 호출(no 옵션을 사용했을 때와 성능 비슷, 기본 옵션)

## 백업 사용 시 주의점
- RDB와 AOF 파일을 사용하는 경우 인스턴스의 maxmemory 값은 실제 서버 메모리보다 여유를 갖고 설정.
  - RDB 파일을 저장하거나 AOF를 재구성할 때 레디스는 fork()를 이용해 자식 프로세스를 생성한다. 생성된 자식 프로세스는 레디스 메모리를 그대로 파일에 저장해야 하며, 기존 부모 프로세스는 다른 메모리의 데이터를 이용해 다른 클라이언트와의 연결을 처리. 이때 레디스는 Copy-On-Write 방식으로 메모리상의 데이터를 하나 더 복사하는 방법을 이용해 백업을 진행하면서도 클라이언트의 요청 사항을 받아 메모리의 데이터를 읽고 수정하는 작업을 진행.
- 하지만, 물리적 메모리에 있는 실제 메모리 페이지가 그대로 복제되기에 레디스는 기존 메모리의 2배를 사용하게 될 수도 있다. 레디스의 maxmemory 값을 너무 크게 설정한 경우 copy-on-write 동작으로 인해 OS 메모리가 가득 차는 상황이 발생할 수 있으며 OOM 문제 발생 가능성
