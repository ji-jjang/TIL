- [레디스 클러스터와 확장성](#레디스-클러스터와-확장성)
  - [스케일 업 vs 스케일 아웃](#스케일-업-vs-스케일-아웃)
  - [레디스 확장성](#레디스-확장성)
  - [레디스 클러스터 기능](#레디스-클러스터-기능)
    - [데이터 샤딩](#데이터-샤딩)
- [레디스 클러스터 동작 방법](#레디스-클러스터-동작-방법)
  - [해시슬롯을 이용한 데이터 샤딩](#해시슬롯을-이용한-데이터-샤딩)
  - [해시태그](#해시태그)
  - [자동 재구성](#자동-재구성)
    - [자동 페일오버](#자동-페일오버)
    - [자동 복제본 마이그레이션](#자동-복제본-마이그레이션)
- [레디스 클러스터 실행](#레디스-클러스터-실행)
  - [클러스터 초기화](#클러스터-초기화)
  - [클러스터 상태 확인](#클러스터-상태-확인)
  - [redis-cli 이용한 클러스터 접근과 리디렉션](#redis-cli-이용한-클러스터-접근과-리디렉션)
  - [페일오버 테스트](#페일오버-테스트)
    - [1. 커맨드를 이용한 페일오버 발생(수동 페일오버)](#1-커맨드를-이용한-페일오버-발생수동-페일오버)
    - [2. 마스터 동작을 중지시켜 페일오버 발생](#2-마스터-동작을-중지시켜-페일오버-발생)
- [레디스터 클러스터 운영](#레디스터-클러스터-운영)
  - [클러스터 리샤딩](#클러스터-리샤딩)
  - [클러스터 확장 - 신규 노드 추가](#클러스터-확장---신규-노드-추가)
    - [1. 마스터로 추가](#1-마스터로-추가)
    - [2. 복제본으로 추가](#2-복제본으로-추가)
  - [노드 제거](#노드-제거)
    - [CLUSTER FORGET](#cluster-forget)
    - [CLUSTER RESET](#cluster-reset)
  - [레디스 클러스터로 데이터 마이그레이션](#레디스-클러스터로-데이터-마이그레이션)
  - [복제본을 이용한 읽기 성능 향상](#복제본을-이용한-읽기-성능-향상)
- [레디스 클러스터 동작 방법](#레디스-클러스터-동작-방법-1)
  - [하트비트 패킷](#하트비트-패킷)
  - [해시슬롯 구성이 전파되는 방법](#해시슬롯-구성이-전파되는-방법)
    - [1. 하트비트 패킷](#1-하트비트-패킷)
    - [2. 업데이트 메시지](#2-업데이트-메시지)
  - [노드 핸드셰이크](#노드-핸드셰이크)
  - [클러스터 라이브 재구성](#클러스터-라이브-재구성)
  - [리디렉션](#리디렉션)
    - [1. MOVE 리디렉션](#1-move-리디렉션)
    - [2. ASK 리디렉션](#2-ask-리디렉션)
  - [장애 감지와 페일오버](#장애-감지와-페일오버)
    - [1. PFAIL 플래그 (Possible failure)](#1-pfail-플래그-possible-failure)
    - [2. FAIL 플래그](#2-fail-플래그)
  - [복제본 선출](#복제본-선출)

# 레디스 클러스터와 확장성
- **확장성(scalability)은 운영 중인 시스템에서 증가하는 트래픽에 유연하게 대응할 수 있는 능력**

## 스케일 업 vs 스케일 아웃
- **스케일 업(scale up)이란 서버의 하드웨어를 높은 사양으로 업그레이드하는 것(수직 확장)**
- **스케일 아웃(scale out)이란 장비를 추가해 시스템을 확장시키는 방식(수펑 확장)**

## 레디스 확장성
- **키의 이빅셩(eviction)이 자주 발생한다면 서버의 메모리를 증가시키는 스케일 업을 고려**
- 키의 이빅션은 레디스 인스턴스 max memory만큼 데이터가 차 있을 때 또다시 데이터를 저장할 때 발생하는 것으로, 서버의 메모미를 늘리고 레디스 인스턴스의 maxmemory 값을 증가시키는 스케일 업
- 레디스는 단일 스레드로 동작하기에 서버에 CPU를 추가한다고 해도 여러 CPU 코어를 동시에 활용할 수 없다음. 그러나 **데이터를 여러 서버로 분할해 관리**하면 다수의 서버에서 요청을 병렬로 처리할 수 있으므로 서버 대수를 늘림으로써 처리량을 선형적으로 확장

## 레디스 클러스터 기능
- **레디스를 클러스터 모스로 사용하면 추가적인 애플리케이션 아키텍처 변경 없이 여러 레디스 인스턴스간 수평 확장 가능**
- 데이터 분산 처리와 복제, 자동 페일오버 가능

### 데이터 샤딩
- **데이터 저장소를 수평 확장하며 여러 서버 간에 데이터를 분할하는 데이터베이스 아키텍처 패턴**
- 레디스에서 클러스터 기능을 사용하면 마스터를 최대 1000개를 확장 
- 데이터 샤딩과 관련된 모든 기능은 레디스 내부에서 자체적으로 관리, 이를 위한 프록시 서버 등의 추가 아키텍처는 필요치 않음 
- 클러스터에서 데이터는 키를 이용해 샤당되며, 하나의 키는 항상 하나의 마스터 노드에 매핑. 클러스터 모든 노드는 키가 저장돼야 할 노드를 알고 있기에 클라이언트가 다른 노드에 데이터를 쓰거나 읽으려 할 때 키가 할당된 마스터 노드로 연결을 리다이렉션. 이 과정은 레디스 노드와 애플리케이션 쪽의 레디스 클라이언트에서 처리. 데이터를 분할 저장할 때 애플리케이션 소스 코드 로직이 변경될 필요가 없기에 샤딩 처리에 들어가는 번거로움 줄일 수 있음
- 클러스터 각각 최소 3대 마스터, 복제본 노드를 갖도록 구성하는 것이 일반적이며, 하나의 클러스터 구성에 속한 각 노드는 서로를 모니터링. 마스터 노드에 장애가 발생하면 이를 인지한 다른 노드들이 마스터에 연결됐떤 복제본 노드를 마스터로 자동 페일오버시키기 때문에 사용자의 추가적인 개입 없이 레디스 가용성 증가. 또한 마스터에 연결된 복제본의 개수를 파악해 잉여ㅇ복제본을 필요한 노드에 연결시키는 복제본 마이그레이션 작업 수행. 이때 클러스터 버스라는 독립적인 통신을 이용. 모든 레디스 클러스터 노드는 다른 레디스 클러스터 노드에서 들어오는 연결을 수신하기 위한 추가 TCP 포트. 클러스터는 모든 노드가 TCP 연결을 사용해 다른 모든 노드와 연결돼있는 풀 매쉬 토폴로지 형태

# 레디스 클러스터 동작 방법
## 해시슬롯을 이용한 데이터 샤딩
- **클러스터 구조에서 모든 데이터는 해시 슬롯에 저장. 레디스는 총 16,384 해시 슬롯. 마스터 노드는 해시 슬롯을 나누어 갖고 있음**
- 레디스에 입력되는 모든 키는 하나의 해시슬롯에 매핑, 해시 함수는 다음과 같음
```redis
HASH_SLOT = CRC16(key) mod 16384
```
- 데이터를 저장할 때 뿐만 아니라 데이터를 읽어올 때도 위의 함수를 이용해 커맨드를 처리할 적절한 마스터 노드를 찾음
- 해시슬롯은 마스터 노드 내에서 자유롭게 이동. 이동 중에도 데이터는 정상적으로 접근. 이러한 특성으로 하나의 클러스터 내에서 마스터 노드의 추가, 삭제는 굉장히 간단하게 처리

## 해시태그
- 클러스터를 사용할 때 다중 키 커맨드 사용 할 수 없음. 다중 키 커맨드는 MGET과 같은 커맨드
- 이유
  - user1:name, user2:name 키는 서로 다른 해시슬롯에 저장. 각 해시슬롯이 6001, 6003 마스터에 저장. 클러스터 키를 이용해 커맨드를 처리할 마스터로 클라이언트 연결을 리다이렉션하기 땜누에 위와 같이 한 번에 2개 이상의 키에 접근해야 하는 커맨드를 처리할 수 없음
  - 해시태그라는 기능을 사용하면 앞서 설명한 알고리즘으로 키를 해시하기 때문에 키는 랜덤으로 해시슬롯에 배정. 하지만 키에 대괄호를 사용하면 전체 키가 아닌 대괄호 사이에 있는 값을 이용해 해시 될 수 있음. 이를 해시태그
  ```redis
  user:{123}:profile
  user:{123}:priflle // 같은 해시슬롯으로, 같은 마스터에 저장
  ```
  - **클러스터 구조에서 다중 키 커맨드를 사용하고 싶다면 해시태그 기능**. 하지만, 너무 많은 키가 같은 해시태그를 갖고 있다면 하나의 해시슬롯에 데이터가 몰릴 수 있기에 키 분배 모니터링 필요

## 자동 재구성
- 센티널 구조는 별개의 센티널 인스턴스가 레디스 노드를 감시하는 구조라면, **클러스터 구조에서는 데이터를 저장하는 일반 레디스 노드가 서로 감시한다는 차이**
- 모든 노드는 클러스터 버스를 통해 통신. 인스턴스에 문제가 생겼을 때 자동으로 클러스터 구조 재구성

### 자동 페일오버
- 페일오버 발생 과정
  - 6001 마스터에 장애가 발생. 6005 복제본은 다른 마스터 노드들에게 페일오버를 시도해도 될지 투표. 투 요청을 받은 다른 마스터 노드는 6001 마스터 노드가 정상이 아니라고 판단할 경우 복제본에게 투표. 과반수 이상의 마스터 노드에서 투표를 받은 6005 복제본이 마스터로 승격 -> 이 상황에서 6005 노드에 장애가 발생하면? `cluster-require-full-converage yes` 설정에 의해 마스터가 하ㄷ라도 정상이 아닐 경우 전체 클러스터 사용 불가
  - 가용성이 중요한 서비스에서 클러스터 노드의 다운타임을 줄이고 싶다면 자동 복제본 마이그레이션이 가능하도록 아무 마스터 노드에 복제본을 하나 더 추가하는 것을 고려하는 것이 좋음

### 자동 복제본 마이그레이션
- 클러스터가 총 7개의 노드로 구성(6001, 6002 마스터는 각각 1개의 복제본, 6003 노드는 2개의 복제본)
- 6001 노드애 장애 -> 6005 노드가 마스터로 승격 -> 6005는 복제본이 없으며, 6002 노드는 1개, 6003 노드는 2개 복제본
- 이 상황에서 레디스 클러스터는 각 마스터에 연결된 복제본 노드의 불균형 파악하여 6003에 연결돼 있는 2개의 복제본 중 하나의 복제본을 6005의 복제본이 되도록 이동. 이를 **복제본 마이그레이션**
```redis
cluster-allow-replica-migraion yes // 마이그레이션 활성화
cluster-migration-barrir 1 // 복제본을 마그레이션 하기 전 마스터가 가지고 있어야 할 최소 복제본 개수
```
- 가장 많은 수의 복제본이 연결된 마스터의 복제본 중 하나가 옮겨지며, FAIL 상태가 아닌 복제본 중 노드 ID가 가장 작은 복제본이 이동될 노드로 선택

# 레디스 클러스터 실행
- **클러스터 모드로 사용하려면 최소 3개**의 마스터 노드 필요. 보통 실제 운영 목적으로 사용할 때 3개의 마스터에 각각 복제본을 추가해 총 6개의 노드로 클러스터를 구성하는 것이 일반적

## 클러스터 초기화
```redis
cluster-enabled yes // 클러스터 활성화

redis-cli -cluster create [host:port] --cluster-replicas 1
```
- `--cluster-replicas 1` 옵션은 각 마스터마다 1개의 복제본을 추가할 것임을 표시
- 로그를 보면 해시슬롯은 마스터에만 할당되며 복제본 노드에는 할당되지 않았음. 복제본 노드는 마스터와 동일한 데이터를 저장하기 땜누에 해시슬롯 내부 데이터를 동일하게 저장하지만, 해시슬롯을 할당받진 않음

## 클러스터 상태 확인
```redis
CLUSTER NODES
```
- 무작위로 현재 클러스터 상태 확인 

## redis-cli 이용한 클러스터 접근과 리디렉션
- **레디스 클러스터에 접속하기 위해서는 클러스터 모드를 지원하는 레디스 클라이어트가 필요**
```redis
127.0.0.1:6379> set user:1 true
(error) MOVED 10778 192.168.0.22:6379 // 해당 키가 들어가야 할 해시 슬롯은 10778, ip는 192.168.0.22 노드
```
- 즉 일반적인 클라이언트를 이용해 데이터를 넣을 때에는 데이터가 저장될 수 있는 노드가 정해져 있고 해당 노드에만 키에 대한 커맨드를 수행시킬 수 있음
- Jedis, Redisson 등의 레디스 클라이언트들은 클러스터 모드 기능 제공. redis-cli를 사용한다면 -c 옵션을 추가해 클러스터 모드로 사용할 수 있고, 이 경우 리디렉션 기능 제공
```redis
$ redis-cli -c 
127.0.0.1:6379> set user:1 true
-> Redirected to slot [10778] located at 192.168.0.22:6379
OK
```
- **대부분 레디스 클라이언트는 리디렉션한 정보를 캐싱해 맵을 생성. 다음번 같은 키에 대해 커맨드를 수행해야 할 경우 에러를 반환해서 커넥션을 옮가는 과정을 거치지 않고 캐싱된 노드로 바로 커맨드를 보낼 수 있게 해 클러스터의 성능 향상. 클러스터에 저장된 맵은 마스터 노드가 추가/삭제되거나, 페일오버가 발생하는 등 클러스터 구조가 변경되면 리프레시**

## 페일오버 테스트

### 1. 커맨드를 이용한 페일오버 발생(수동 페일오버)
- 수동으로 페일오버시키려면 페일오버시키고자 하는 마스터에 1개 이상의 복제본이 연결
- 페일오버를 발생시킬 복제본 노드에서 cluster failover 커맨드를 실행하면 페일오버 발생
```redis
INFO REPLICATION // 복제 연결 상태 확인
```
- 수동 페일오버가 진행되는 동안 기존 마스터에 연결된 클라이언트는 잠시 블락
- 페일오버를 시작하기 전 복제 딜레이를 기다린 뒤, 마스터 복제 오프셋을 복제본이 따라잡는 작업이 완료되면 페일 오버 시작
- 페일오버가 완료되면 클러스터의 정보를 변경, 모든 작업이 완료되면 클라이언트는 새로운 마스터로 리디렉션

### 2. 마스터 동작을 중지시켜 페일오버 발생
- 직접 마스터 노드에 장애를 발생시킨 뒤 페일오버가 잘 발생하는지 확인하여 마스터의 상태가 정상이 아닐 경우 다른 노드에서 이를 인지할 수 있는지 확인
```redis
redis-cli -h <master-host> -p <master-port> shutdown
```
- 클러스터 구조에서 복제본은 redis.conf에 지정한 cluster-node-timout 시간 동안 마스터에서 응답이 오지 않으면 마스터의 상태가 정상적이지 않다고 판단해 페일 오버를 트리거. 기본값은 15,000 밀리초(15초)
- `cluster nodes`로 클러스터 상태 확인

# 레디스터 클러스터 운영
## 클러스터 리샤딩
- **마스터 노드가 가지고 있는 해시슬롯 중 일부를 다른 마스터로 이동하는 것을 리샤딩**
```redis
$ redis-cli --cluster reshared 192.168.0.66 6379 // 일부 해시슬롯 리샤딩
```
- 이동시킬 슬롯의 개수를 정해야 함
- 해시슬롯 이동시킬 노드의 입력이 끝나면 리샤딩이 진행될 소스와 데스티네이션 마스터 노드 정보를 확인할 수 있음
- 모든 작업이 끝난 뒤 `cluster check` 커맨드를 이용해 클러스터 정보를 확인
```redis
redis-cli --cluster reshared <host>:<port> --cluster-from <node-id> --cluster-to <node-id> --cluster-slots <number of slots> --cluster-yes
```
- `--cluster -yes` 모든 프롬프트에 자동으로 yes. 자동으로 클러스터 리샤딩 작업 진행. 

## 클러스터 확장 - 신규 노드 추가
- **마스터 노드를 확장하거나 복제본 노드를 추가할 때 모두 레디스에는 데이터가 저장되지 않은 상태여야 함. 비어 있지 않은 노드를 추가하고자 할 때에는 에러 발생**
- 추가하고자 하는 노드도 `cluster-enabled yes`로 클러스터 노드로 실행된 상태
### 1. 마스터로 추가
```redis
redis-cli cluster add-node <추가할 노드 IP:PORT> <기존 노드 IP: PORT>
```
- 새로운 노드를 추가하기 전 기존 노드의 상태를 확인한 뒤 새로운 노드를 추가
- 마스터 노드가 추가되더라도 할당된 해시슬롯이 없기에 데이터 보유 불가. **리샤딩 기능을 사용해 직접 해시슬롯 할당하는 과정 거쳐야 함**
### 2. 복제본으로 추가
```redis
redis-cli cluster add-node <추가할 노드 IP:PORT> <기존 노드 IP: PORT> --cluster-slave[--cluster-master-id <기존 마스터 ID>]
```
- `--cluster-master-id` 옵션으로 복제본의 마스터가 될 노드를 지정해주면 신규로 추가하는 노드는 지정한 마스터에 복제본으로 추가
- `--cluster-slave` 옵션을 이용해 노드를 추가할 때는 추가되는 노드가 임의의 마스터 복제본에 연결. 만약 클러스터가 비대칭적이라면 복제본이 적은 마스터에 연결되어 균형 유지

## 노드 제거
```redis
redis-cli --cluster del-node <기존 노드 IP:PORT> <삭제할 노드 ID>
```
- 첫 번째 인수로는 기존 클러스너 노드 중 하나의 노드 정보, 두 번째 인자로는 삭제하려는 노드의 ID 입력
- 제거하려는 노드가 마스터 노드인지 복제본 노드인지에 상관 없이 삭제할 수 있음. 단, 마스터 노드는 제거 하기 전 데이터가 없는 상태여야 함. 할당된 해시슬롯이 하나도 없도록 리샤딩 작업 필요 혹은 수동으로 페일오버를 진행한 뒤 노드의 역할을 복제본으로 만든 뒤 클러스터에서 제거 가능

### CLUSTER FORGET
- 클러스터를 제거하기 위해서는 제거될 노드에서 클러스터 구성 데이터를 지우는 것 뿐만 아니라, 클러스터 내 다른 노드들에게도 해당 노드를 지우라는 커맨드를 함께 보내야 함
- `CLUSTER FORGET <node-id> 커맨드를 수신한 노드는 노드 테이블에서 제거할 노드의 정보를 지운 뒤, 60초 동안 이 노드 ID를 가지고 있는 노드와 신규로 연결되지 않도록 설정
- 클러스터 구성에서 노드들은 가십 프로토콜을 이용해 통신하기에 신규 클러스터 노드를 자동으로 감지해 새로운 노드로 추가할 수 있음. 따라서 60초 동안 제거한 노드의 ID가 다시 추가되는 것을 차단하지 않으면 다른 노드에 의해 제거된 노드를 다시 클러스터에 추가할 가능성이 존재
### CLUSTER RESET
- 제거될 노드에서 수행. 두 가지 옵션이 존재하며 기본값은 SOFT
```redis
CLUSTER RESET [SOFT/HARD]
```
- HARD 리셋은 1~5 모두 진행, SOFT 리셋은 1~3 진행
  1. 클러스터 구성에서 복제본 역할을 했었다면 노드는 마스터로 전환되고, 노드가 가지고 있던 모든 데이터셋은 삭제. 노드가 마스터이고 지정된 키가 있다면 리셋 작업 중단
  2. 노드가 해시슬롯을 가지고 있었다면, 모든 슬롯이 해제. 만약 페일오버가 진행되는 상황이었다면 페일오버에 대한 진행 상태도 초기화
  3. 클러스터 구성 내 다른 노드 데이터가 초기화. 기존에 클러스터 버스를 통해 연결됐던 노드를 더 이상 인식 불가
  4. currentEpoch, configEpoch, lastVoteEpoch 값이 0으로 초기화
  5. 노드의 ID가 새로운 임의 ID로 변경

## 레디스 클러스터로 데이터 마이그레이션
- 기존에 싱글 혹은 센티널 구성으로 사용하고 있던 **레디스 인스턴스를 가용성과 확정성을 위해 클러스터 구성의 레디스로 마이그레이션 고려**
- 기존 애플리케이션에서 다중 키 커맨드를 사용하지 않았을 경우 커넥션 변경 이외의 데이터 저장 로직은 문제 없음. 사용했을 경우 해시태그를 사용하도록 애플리케이션 로직 수정
- 데이터를 전달받을 클러스터 노드에서 소스 레디스 노드로 데이터 import 요청. 데이터가 저장될 클러스터 노드는 해시슬롯 16,384개가 정상적으로 할당된 상태. 클러스터 내 마스터 노드에 모두 접근 가능한 상태로 준비. 데이터의 소스 노드 또한 접근이 가능한 온라인 상태. 클라이언트와 소스 레디스 노드 간 네트워크 통신 미리 확인
- 운영 중인 레디스 데이터를 마이그레이션 할 때 소스 레디스에 연결된 클라이언트 모두 중단시키는 것 권장. **마이그레이션 도중 원본 레디스 노드에서 변경되거나 추가된 데이터는 마이그레이션되는 클러스터에 반영되지 않기 때문**
```redis
redis-cli --cluster import 192.168.0.11:6379 --cluster-from 192.168.0.88:6379 --cluster-copy
```

## 복제본을 이용한 읽기 성능 향상
- **레디스 클라이언트는 기본적으로 키를 요청하면 키를 갖고 있는 마스터 노드로 연결을 리디렉션. 마스터에 연결된 복제본 노드는 같은 데이터를 갖고 있기에 키를 읽을 수 있지만, 이 경우에도 우선 마스터로 연결이 변경**
- 마스터 노드에 키를 저장하고, 이떄 데이터를 가지고 있는 복제본의 마스터 노드에서 데이터를 읽어오려 할 때 에러가 발생. 클러스터 지원하는 클라이언트를 사용할 경우 마스터로 연결 리다이렉션
- 애플리케이션 읽기 성능을 위해 복제본 노드를 읽기 전용으로 사용하고 싶다면? 복제본으로 맺어지는 커넥션을 READONLY 모드로 변경해 클라이언트가 복제본 노드에 있는 데이터를 직접 읽을 수 있도록 설정
```redis
redis-cli -h 192.168.0.55 -c

192.168.0.55> readonly
OK
192.168.0.55> get hello
"world"
```


# 레디스 클러스터 동작 방법
- 내부적으로 어떻게 동작하는 지 알면 문제가 생겼을 때 장애 지점을 파악하기 쉬워질 수 있음

## 하트비트 패킷
- **레디스 클러스터 노드들은 지속적으로 서로의 상태를 확인하기 위해 PING, PONG 패킷을 주고 받음**. 이 두 패킷을 묶어서 하트비트 패킷. 클러스터가 주고받는 유형의 패킷에 가십 섹션이 추가된 형태
- 패킷의 헤더
  - 노드 ID
  - 현재 에포크/구성 에포크: 분산 환경에서 일관성 유지
  - 노드 플래그: 노드가 마스터 혹은 복제본 여부
  - 비트맵: 마스터가 제공하는 해시슬롯 비트맵 정보. 복제본인 경우 마스터 정보
  - TCP 포트
  - 클러스터 포트: 발신 노드의 노드 간 커뮤니케이션을 위한 포트
  - 클러스터 상태: 발신 노드 관점에서 봤을 때 클러스터 상태
  - 마스터 노드 ID: 복제본 노드인 경우 마스터 노드 ID

## 해시슬롯 구성이 전파되는 방법
- 레디스 클러스터에서 가장 중요한 기능 중 **하나는 커맨드에서 사용한 키의 해시슬롯이 어디에 있는지 파악해 정확한 해시슬롯의 위치를 알려주는 것**

### 1. 하트비트 패킷
- 마스터 노드가 PING, PONG의 패킷을 보낼 때 항상 자기가 갖고 있는 해시슬롯을 패킷 데이터에 추가

### 2. 업데이트 메시지
- 하트비트 패킷에는 발신하는 노드 구성 에포크 값이 포함. 패킷을 보낸 노드의 에포크 값이 오래됐다면 해당 패킷을 받은 노드는 신규 에포크의 구성 정보를 포함한 업데이트 메시지를 노드에 보내 하트비트 패킷을 보낸 노드의 해시슬롯 구성 업데이트
  
> 해시슬롯 구성 변경은 페일오버와 리댜싱 중에만 발생. 페일오버와 리샤딩하는 작업 모두 에포크가 증가하는 작업이기에 작업 이후 변경 사항을 클러스터 전체에 전파. **클러스터 모든 노드는 가장 큰 구성 에포크 값을 가진 노드에 동의하기에 클러스터 내 모든 값 업데이트 가능**

## 노드 핸드셰이크
- 한 노드가 클러스터에 합류하기 위해서는 `CLUSTER MEET` 커맨드를 다른 노드에 보냄. 해당 커맨드를 수신한 노드는 자신이 알고 있는 다른 노드들에게 전파하고, 이 정보를 수신한 노드가 신규 합류한 노드를 모르는 상태라면 해당 노드와 CLUSTER MEET을 통해 신규 연결을 맺음. (이미 알았다면 커맨드 무시)
- 이와 같은 방식으로 클러스터 내부 모든 노드들은 풀 매쉬 연결 (방향성 없음)
- 외부 클러스터 연결되는 것을 막을 수 있음

## 클러스터 라이브 재구성
- 클러스터가 정상적으로 운영되는 동안 새로운 마스터 노드를 추가하거나 기존 마스터 노드 제거 가능
  - 클러스터에 새로운 노드를 추가하려면 빈 노드를 클러스터에 추가한 뒤, 일부 해시슬롯을 기존 마스터에서 신규 슬롯으로 옮김
  - 클러스터에서 노드를 제거하려면 해당 노드를 빈 노드로 만들기 위해, 갖고 있던 해시슬롯을 다른 노드로 보냄

> 두 작업 모두 결국 하나의 노드 내 해시슬롯을 다른 노드로 옮기는 작업이 동반. 해시슬롯 또한 결국 논리적인 키의 집합이기에 레디스 클러스터가 실제로 하는 일은 하나의 마스터 노드에서 다른 마스터 노드로 데이터를 옮기는 일

```redis
CLUSTER SETSLOT 8 MIGRATING B // A가 갖고 있는 해시슬롯 8을 B로 옮김

CLUSTER GETKEYINSLOT slot count // 해시슬롯 8에 속한 키를 A에서 B로 마이그레이션, 지정한 해시슬롯이 가지고 있는 키를 반환, 반환된 모든 키에 대해 노드 A에 MIGRATE 커맨드 전송. 원자적으로 진행
```
- MIGRATE는 대상 인스턴스에 연결해서 키를 전송하고, OK 코드를 받으면 기존 데이터셋에서 키를 삭제. 외부 클라이언트에서 봤을 때 키는 양쪽에 존재할 수 없음. 마이그레이션 프로세스가 완료되면 두 노드에게 모두 `SETSLOT <slot> NODE <node-id>` 커맨드 전송 후 다른 모드로 전파
```redis
MIGRATE target-host target-port key target-database id timeout
```

## 리디렉션
- 실시간 트래픽이 많은 서비스에선 속도가 굉장히 중요하며, 다른 노드에 커넥션을 다시 한번 맺는 과정이 많아졌을 때 성능 문제가 발생할 수 있기에 리디렉션을 구분해 구현

### 1. MOVE 리디렉션
- `요청하는 해시슬롯이 저 노드에 있으니 앞으로 이 키에 대한 요청은 저 노드로 보내`라는 것을 의미
- 클라이언트가 보낸 커맨드가 단일 키 커맨드인지 혹은 다중 키인 경우 언급된 여러 키가 모두 동일한 해시슬롯에 있는지 파악한 뒤 키가 속한 해시슬롯을 포함한 마스터 노드를 찾음. 원하는 데이터가 있는 경우 해시슬롯에서 찾아 바로 반환. 아니라면 어떤 노드가 어떤 해시슬롯을 갖고 있는지 해시슬롯 맵을 확인한 후 MOVED 에러로 클라이언트에게 응답 
- 이후 애플리케이션에서 이 키를 다시 조회하려고 할 경우, 클라이언트엫서 바로 올바른 마스터 노드로 조회할 수 있어 리디렉션 과정을 생략하여 시간 생략. 클러스터가 안정적일 때 모든 클라이언트는 해시슬롯, 노드의 맵을 갖고 있으며, 직접 올바른 노드를 찾아갈 수 있어 SPOF이 없는 효율적인 서비스

### 2. ASK 리디렉션 
- `지금 요청한 이 쿼리는 저 노드에서 수행해. 하지만 다음 노드는 다시 나한테 보내`라는 의미
- 동작 과정
  1. 리디렉션 오류가 반환된 노드 정보로 쿼리르 재전송하지만, 이후에 같은 키에 대한 쿼리가 들어오면 기존에 전송한 노드에 다시 보냄
  2. 리디렉션을 받은 값으로 클라이언트의 해시슬롯 맵을 업데이트하지 않음
- A가 갖고 있던 해시슬롯 8을 B로 옮기는 과정
  - 해시슬롯을 옮기는 도중 클라이언트가 해시슬롯 89에 포함된 키인 user:1을 조회
  - 만약 클라이언트 B 노드에 이 키 값을 요청한다면 B는 리디렉션 요청(MOVED가 아닌 ASK 요청)
  - 마이그레이션 과정 완료되면 9번 해시슬롯은 B로 이동될 예정이므로, 그 후의 요청은 B로 전송되어야 함
  - 마이그레이션 완료 후 레디스는 ASk 리디렉션을 사용해 클라이언트의 연결을 A로 단 한번만 전환. 클라이언트 맵이 업데이트되지 않아서, 이후에 user:1을 조회하면 커맨드는 바로 B로 연결
  - 만약 마이그레이션 완료 후 다른 클라이언트가 A에 user:1 대한 커맨드를 수행하면 이때에는 MOVED 리디렉션 이용. 해시슬롯 소유하고 있는 노드가 완전히 변경됐으므로 클라이언트의 해시슬롯 맵을 업데이트해 다음 연결이 지속적으로 B로 이뤄지게 하는 것이 적절

## 장애 감지와 페일오버
### 1. PFAIL 플래그 (Possible failure)
- PFAIL: 일부 노드에서는 해당 노드에 접근할 수 없지만, 아직 확실하지 않은 실패. FAIL은 대다수의 노드에서 해당 노드에 장애가 발생했음을 동의한 상태
- 특정 노드에 NODE_TIMEOUT 시간 이상 도달할 수 없는 경우 해당 노드에 대해 PFAIL 플래그로 표시. 마스터, 복제본에 관계 없이 플래그 가능

### 2. FAIL 플래그
- 실제로 마스터 노드에 장애가 발생했다고 인지해서 페일오버를 트리거시키기 위해서는 FAIL 상태

## 복제본 선출
- 페일오버 직접 시도 조건
  1. 마스터가 FAIL 상태
  2. 마스터는 1개 이상의 해시슬롯 갖고 있음
  3. 마스터와의 복제가 끊어진지 오래
- 위 조건을 모두 만족했을 때 복제본은 마스터로 선출되기 위해 자신의 현재 에포크 값을 1 증가시키고, 마스터 인스턴스에 투표를 요청
- 복제본은 클러스터의ㅂ모든 마스터 노드에 `FAILOVER_AUTH_REQUEST` 패킷을 보내 투표ㅊ요청
- 요청을 받은 마스터는 `FAILOVER_AUTH_ACK` 패킷으로 긍정적인 응답을 보내 동의
- 마스터는 동시에 승격하는 것을 방지하기 위해 `NODE_TIMEOUT*2`시간 동안은 같은 마스터로 승격되고자 하는 다른 복제본에게 투표할 수 없음
- 응답을 받은 복제본은 현재 에포크 갑솝다 작은 에포크로 온 AUTH_ACK에 대한 응답은 무시하기에 이전 버전의 투표에 대한 응답은 거를 수 있음
- 다수의 마스터로부터 ACK를 받은 복제본이 마스터 후보로 선출, NODE_TIMEOUT\*2 시간 동안 과반수 이상의 마스터에서 ACK가 오지 않으면 페일오버는 중단. 이후 NODE_TIMEOUT\*4만큼 지연 후 다시 새로운 투표를 시도 
- 마스터가 FAIL 상태가 된 이후 복제본은 다음과 같이 계산된 짧은 딜레이를 가진 뒤 투표를 시작
```redis
DELAY = 500ms + 랜덤 지연 시간(0~500ms) + SLAVE_RANK * 1000ms
```
- 랜덤한 지연 시간을 이용해 같은 마스터에 연결된 여러 복제본에서 동시에 투표를 시작하는 것을 방지할 수 있음
- `SLAVE_RANK`는 마스터에서 처리한 복제 데이터 양과 관련된 복제본의 우선순위. 마스터가 FAIL 상태가 되면 복제본끼리 메시지를 교환하는데, 가장 최근의 오프셋을 가진 복제본이 0순위, 두 번째는 1순위와 같은 방식으로 우선순위 부여