# 레디스 모니터링 구축
## 프로메테우스와 그라파나를 이용한 레디스 모니터링
- 익스포터(exporter)란 시스템의 상태를 실시간으로 스크랩해서 메트릭을 수집하는 프로그램
- 레디스 익스포터는 지정한 레디스 인스턴스의 실시간 정보를 수집. 노드 익스포터는 레디스가 실행되는 서버의 하드웨어와 OS 관련 메트릭 수집
- 프로메테우스는 메트릭 기반 오픈 소스 모니터링 시스템 
- 그라파나는 오픈 소스 메트릭 데이터 시각화 도구
- 서버 2대로 모니터링 구축
  - 10.0.0.1 서버에서는 6379포트로 레디스. 9121포트로 레디스 ㅍ스포터. 9100 포트로 노드 익스포터 실행
  - 10.0.0.2 서버에서는 프로메테우스와 그라파나를 각각 설치한 뒤 익스포터를 이용해 뎅이터를 수집하며 그라파냐를 이용해 대쉬보드 확인
### 1. 노드 익스포터 설치
### 2. 레디스 익스포터 설치
### 3. 얼럿(alert) 매니저 설치
### 4. 모니터링 서버에 프로메테우스 설치
### 5. 그라파냐 설치

## 레디스 플러그인을 이용한 그라파나 대시보드
- 프로메테우스라는 중간 저장소 없이 그라파나에서 레디스의 데이터를 확인하고, 실시간 변경
- 그라파냐에서 레디스 플러그인 설치하면 RedisGrafana에서 제공하는 대시보드를 이용해 실시간 레디스 상태 확인 가능(레디스 익스포터 설치 필요 X)
- 그라파냐에서 직접 레디스로 커맨드 수행할 수 있는 패널 제공
# 레디스 버전 업그레이드
- 레디스 릴리즈 주기 잦고 EOL(End Of Life)도 짤븡ㅁ
- 크게 두 가지 방법
## 1. 복제 방식
- **업그레이드할 버전 레디스 인스턴스를 새로운 서버에 설치한 뒤, 기존 버전의 레디스 데이터를 복제하는 방식**
- **운영 중인 애플리케이션에서 레디스로의 접속 정보를 변경. 하지만, 접속 정보를 변경하는 것 외에는 다운 타임이 존재하지 않음
## 2. 재실행 방식
- **실행 중인 레디스 인스턴스를 중지한 다음, 신규 버전의 레디스 소스 파일로 재실행하는 방식**
- 레디스 접속 정보를 변경하지 않아도 되지만, 싱글 구성의 레디스였다면 다운타임이 발생

> 보통 센티널 혹은 클러스터 구조의 고가용성 구성으로 이뤄진 인스턴스라면 복제본부터 하나씩 업그레이드해가며 전체 레디스 버전을 업그레이드. 싱글 혹은 센터닐을 사용하지 않는다면 다운타임이 발생되거나 접속 정보를 변경해야 하기 때문에 상황에 맞는 방법 선택

## 센티널 구성 레디스 버전 업그레이드
1. 신규 버전의 레디스 바이너리 파일 다운로드
2. 3대의 센티널 인스턴스 모두 중단
3. 신규 버전 폴더에 기존의 sentinel.conf 복사
4. 신규 바이너리 파일을 이용해 3대의 센티널 인스턴스 시작
5. 복제본 인스턴스 중단
6. 신규 버전 폴더에 기존의 redis.conf 복사
7. 신규 바이너리 파일을 이용해 복제본 인스턴스 시작
8. 센티널에서 수동 페일오버 실행
9. 기존 마스터 인스턴스 중단
10. 신규 버전 폴더에 기존의 redis.conf 복사
11. 신규 바이너리 파일을 이용해 기존 마스터 인스턴스 시작
12. 센티넬에서 수동 페일오버 수행

## 클러스터 구성 레디스 버전 업그레이드
- 클러스터 각 레디스 인스턴스를 A, B, C, D, E, F라 하고, A, B, C 인스턴스가 마스터 그리고 D, E, F가 각각 A, B, C의 복제본일 때 다음과 같은 순서로 업그레이드
1. D, E, F 노드 각각 버전 업그레이드
2. D 노드에서 페일오버
3. A 노드 업그레이드
4. E 노드 페일오버
5. B 노드 업그레이드
6. F 노드 페일오버
7. C 노드 업그레이드

# 레디스 운영 가이드
## 장애 또는 성능 저하를 유발할 수 있는 레디스 설정 항목
### 1. maxmemory-policy
- 레디스가 메모리 한계에 도달했을 때 어떤 키를 제거해야 할지 결정하는 설정값. 기본값은 noeviction. 레디스에 데이터가 가득 차더라도 임의로 데이터 삭제하지 않음
- 레디스의 일부 데이터가 임의로 삭제되더라도 계속해서 새로운 입력을 받아들일 수 있도록 설정하고 싶다면 이 값을 `allkey-lru`로 설정

### 2. stop-writes-on-bgsave-error
- RDB 스냅숏이 정상적으로 저장되지 않을 때 레디스로의 모든 쓰기 작업을 중지하는 역할
- 최신 백업이 실패한 것을 인지하고 서버에 문제가 있음을 알려줘 더 큰 장애 방지 가능. 그러나 레디스 서버에 이미 다른 모니터링 기능이 활성화돼 있어 디스크 문제가 발생해도 이를 신속하게 감지할 수 있으며, 레디스의 쓰기 작업은 중단되지 않고 계속 되기를 언한다면 이 설정을 비활성화(기본 설정값은 yes)

### 3. 자동 백업 옵션
- 레디스에서 RDB와 AOF를 사용해 백업 파일을 생성하는 작업은 운영 중인 레디스 인스턴스에 큰 부하. 백업이 포그라운드로 수행된다면, 다른 작업은 대기해야 하므로 성능에 영향. 백그라운드로 실행될 때에는 COW로 동작하기에 메모리 사용량이 최대 maxmemory의 두배까지 증가할 수 있음  
- 백업 작업은 의도한 시간에 의도한 레디스 인스턴스에서 실행될 수 있도록 설정
```redis
> CONFIG GET save
1) "save"
2) "3600 1 300 100 60 10000"
```
- 1시간 동안 적어도 1번의 변경 작업이 수행되거나, 5분 동안 적어도 100번의 변경 작업이 수행되거나, 1분 동안 적어도 10000번의 변경 작업이 수행되는 조건에 해당하면 자동으로 RDB 파일을 생성
- 대규모 트래픽 환경에서 기본값을 설정한다면 백업 빈도가 너무 높아질 수 있으므로 기본값 변경 권장
- `appendonly` 옵션을 yes로 하여 AOF 형식의 백업을 수행하는 경우에도 AOF 파일 크기가 기존의 100% 증가하면 자동 재작성이 발생한다. `auto-aof-rewrite-percentage` 값을 0으로 변경해서 자동으로 재작성하는 것을 방지할 수 있음

## 레디스 운영 및 성능 최적화
### 1. 오래 걸리는 커맨드 사용
- 레디스 싱글 스레도 동작. 클라이언트 요청은 모든 이벤트 루프를 이용해서 순차적 실행되는 특징. 레디스에서 O(N)이상의 시간 복잡도를 갖는 커맨드를 사용하는 것은 지양
- set, list, hash와 같이 하나의 자료 구조 안에 여러 개의 아이템을 가지고 있는 경우 해당 자료 구조에 대한 커맨드도 아이템 개수에 비례해 실행 시간이 증가하므로 주의

#### 1) 키스페이스 커맨드(KEYS, FLUSHALL, FLUSHDB)

> 기본값은 동기이지만, 설정값을 변경해 비동기적으로 삭제하도록 구성 가능
> lazyfree-lazy-eviction: 메모리 제한을 위한 데이터 삭제 시, 동기적 삭제 여부 결정
> lazyfree-lazy-expire: 만료 시간이 지난 키의 동기적 삭제 여부 결정
> layfree-lazy-server-del: 서버 동기화나 다른 명령어 사이드이펙트로 인한 키 삭제 시, 동기적 삭제 여부 결정
> replica-lazy-flush: 복제 동기화 시 데이터베이스 내용 삭제할 때 동기적 삭제 여부 결정
> lazyfree-lazy-user-del: 사용자 코드에서 DEL 호출을 UNLINK 호출과 동일하게 처리
> 이러한 lazyfree 설정값을 yes로 지정하더라도 동기적으로 키가 삭제되는 경우도 존재. 레디스는 먼저 lazyfreeGetFreeEffort 함수를 호출해 특정 키의 메모리를 해제하는 데 드는 노력을 계산하여 가벼운 연산이라면 동기적으로 동작하기 때문. 이러한 메커니즘은 레디스 메모리 해제 작업의 오버헤드를 줄이고, 메모리 관리 및 성능 특성을 세밀하게 조정하는 데 도움

#### 2) 자료구조 공통ㅁ커맨드(DEL, SORT, SORT_RO)

#### 3) set 관련 커맨드(SDIFF, SDIFFSTORE, SUNION, SUNIONSTORE, SINTER, SINTER, SINTERSOTORE, SINTERCARD) 

#### 4) list 관련 커맨드(LINDEX, LINSERT, LSET, LPOS)

#### 5) hash 관련 커맨드(HGETALL, HKEYS, HVALS)

#### 6) sorted set 관련 커맨드(ZDIFF, ZDIFFSTORE, ZUNION, ZUNIONSTORE, ZINTER, ZINTERSTORE, ZINTERCARD)

### 2. 레디스 트랜잭션 사용과 주의 사항
- 레디스는 싱글 스레드로 동작하기에 주의. 두 가지 방식으로 트랜잭셩 사용 가능

#### 1) MULTI / EXEC
- MULTI는 트랜잭션을 시작하는 커맨드. 이후 트랜잭션에서 실행하고자 하는 커맨드를 입력. EXEC 커맨드를 사용하면 입력했던 커맨드를 원자적으로 실행하고, 트랜잭션이 성공하면 결과를 반환
- 트랜잭션 도중 오류가 발생하면 트랜잭션 내 모든 커맨드를 롤백하고 트랜잭션 종료 

#### 2) 루아 스크립트
- 루아 스크립트는 가볍고 빠르며 임베디드가 가능한 스크립트 언어. 레디스는 루아 스크립트 실행 기능을 내장해 데이터 조작 및 계산과 같은 작업을 처리
- 루아 스크립트는 레디스 내 원자적으로 실행되므로 여러 명령을 한 번에 실행하고 중간에 다른 클라이언트 요청을 수용하지 않아 데이터 일관성 유지
- 트랜잭션과 비슷한 원자성을 갖지만, **트랜잭션과 달리 일부 명령어가 실패하더라도 다음 명령어로 진행되며 롤백이 발생하지 않음**
- 루아 스크립트를 적절하게 활용하면 데이터를 매번 네트워크로 전송하지 않고 서버에서 계산을 수행해 애플리케이션 성능을 향상시킬 수 있음
- 레디스에서 스크립트를 로드하고 실행하려면 `SCRIPT LOAD, EVALSHA` 사용

> **트랜잭션과 루아 스크립트를 사용하는 도중 다른 클라이언트 커맨드는 모두 대기하게 되므로 트랜잭션의 길이가 길어지지 않도록 각별한 주의가 필요**
> 또한, 블로킹 커맨드를 사용할 수 없는데 그 이유는 트랜잭션 내부에서 블로킹 될 경우 레디스는 무한 대기 상태에 빠질 수 있기 때문

### 3. has-get / has-del 패턴
- 데이터 조회 또는 삭제 시 EXISTS 커맨드를 사용해 데이터 존재 여부를 확인한 뒤 처리하는 has-get 및 has-del 방식은 지양. 네트워크 부하를 늘리며 불필요한 작업을 수행해 애플리케이션 성능을 저하
- 키의 존재 여부를 확인하고 다음 커맨드를 수행하기 전까지 다른 클라이언트가 변경하거나 수정할 수 있으므로 원자성 문제를 야기

### 4. 클라이언트 출력 버퍼 사이즈
- 일반적인 상황에서 버퍼 크기는 기본 설정값으로도 충분하지만,ㅌ대용량 데이터를 처리하거나 많은 커맨드를 처리하는 경우 출력 버퍼의 크깆가 작으면 데이터 전송 중 오버플로우 발생
- 특히 동시에 많은 클라이언트 요청을 처리하는 환경에서는 출력 버퍼의 크기를 늘리는 게 권장
- 복제를 사용하는 경우 출력 버퍼를 늘리는 것은 필수적
```redis
client-output-buffer-limit <클래스> <하드 제한> <소프트 제한> <소프트 초>
client-output-buffer-limit normal 0 0 0 # 제한 없이 데이터 수신 가능
client-output-buffer-limit replica 256mb 63mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
```
### 5. 특정 프리픽스를 가진 키 삭제
- 삭제 작업은 마스터 인스턴스에서만 수행 가능
- 운영 중인 레디스 환경에 최소환의 영향을 미치며 삭제하는 방법
  - SCAN 명령어를 사용해 특정 프리픽스를 가진 키 검색. 검색된 키 삭제
  - 레디스에서 1000만 개의 키가 있고, 매치하는 패턴이 100만 개 있다면 SCAN 작업 이후 레디스에 100만 번의 추가 접근이 필요. 각 키를 하나씩 삭제하기 위해 왕복 시간 소요(모든 키에 접근할 때까지 반복, 모든 키를 삭제할 때까지 반복)
  - 루아 스크립트를 이용한다면 네트워크 I/O를 줄임 (모든 키에 접근할 때까지만 반복). 단점은 스크립트가 실행되는 동안 다른 커맨드 차단(배치 사이즈 고려)

## 레디스 모니터링
### 1. 슬로우 로그
- 실행 속도가 느린 커맨드를 기록하는 로그. 슬로우 로그를 주기적으로 모니터링해 느린 커맨드를 추적하고 디버깅하여 성능 개선
```redis
SLOWLOG GET
```
- 슬로그 로그에 남는 기준은 `slowlog-log-slower-than` 설정값으로 변경. 기본은 10초
- `slowlog-max-len` 슬로우 로그에 유지되는 레코드 개수 제한. 기본은 128개

### 2. CPU
- 레디스를 실행하는 동안은 단일 스레드로 동작. 백업 파일 저장 및 UNLINK와 같은 백그라운드 작업 시에는 다른 CPU 이활용 가능

### 3. 메모리
- DatabseMemoryUsagePercentage가 100%에 도달하면 maxmemory 정책이 작동하며, 설정에 따라 이빅션 발생 가능. 이빅션은 레디스를 캐시로 사용하는 경우 데이터 관리를 위해 의도적으로 사용될 수 있음
- 메모리 단편화 문제 발생 가능. 특정 시점에 키가 갑작스럽게 몰렸다가 갑자기 삭제 되거나 만료 시간으로 인해 한꺼번에 이빅션이 많이 발생하는 경우. 메모리 단편화 문제가 심각하게 발생한다면 `active degramentation` 기능을 활성화 