# 레디스 캐시로 사용하기
- **캐시란 데이터의 원본보다 더 빠르고 효율적으로 접근할 수 있는 임시 데이터 저장소를 의미**한다.
- 다음 조건에서 캐시를 도입했을 때 성능을 효과적으로 개선할 수 있다.
  1. **원본 데이터 저장소에서 원하는 데이터를 찾기 위해 검색하는 시간이 오래 걸리거나, 매번 계산을 통해 데이터를 가져와야 한다.**
  2. **캐시에서 데이터를 가져오는 것이 원본 데이터 저장소 데이터를 요청하는 것보다 빨라야 한다.**
  3. **캐시에 저장된 데이터는 잘 변하지 않는 데이터이다.**
  4. **캐시에 저장된 데이터는 자주 검색되는 데이터이다.**
- 레디스는 모든 데이터를 메모리에 저장하는 인메모리 데이터 저장소이기 때문에 관계형 데이터베이스보다 더 빠르다.
- 레디스의 클러스터를 사용하면 스케일 아웃을 쉽게 처리할 수 있다. (수평 확장 간단)

## 캐싱 전략
### 1. 읽기 전략 - look aside
![look aside](../images/redis/cache-session/1.png)
- 동작 과정
  1. 찾고자 하는 데이터가 먼저 캐시에 있는지를 확인한 뒤, 캐시에 데이터가 있으면 캐시에서 데이터를 읽어온다. (**캐시 히트**)
  2. 찾고자 하는 데이터가 없을 때에는 **캐시 미스**가 발생한다. 직접 데이터베이스에 접근해 찾고자 하는 데이터를 가져오고, 이를 다시 캐시에 저장한다.
- 레디스에 문제가 생겨 접근을 할 수 없는 상황이 발생해도 서비스 장애로 이어지지 않는다. 하지만, DB에는 연결된 커넥션 만큼 부하가 발생한다.
- 미리 데이터베이스에 데이터를 밀어넣어주는 작업을 **캐시 워밍**이라고 한다. 

### 2. 쓰기 전략    

> 캐시는 데이터베이스에 저장돼 있는 데이터를 단순히 복사해 온 값이다. 따라서 **원본 데이터와 동일한 값을 갖도록 유지하는 것이 필수적**이다.

#### 1) write through
![write through](../images/redis/cache-session/2.png)
- **데이터베이스에 업데이트할 대마다 매번 케시에도 데이터를 업데이트**한다.
- 캐시는 항상 최신 데이터를 가지고 있다는 장점이 있지만, 매번 2개의 저장소에 저장되기 때문에 오버헤드가 있다.
- 다시 사용하지 않는 데이터도 무조건 캐시에 저장되기 때문에 만료 시간 설정이 권장된다.

#### 2) cache invalidation
![cache invalidation](../images/redis/cache-session/3.png)
- **데이터베이스에 값을 업데이트할 때마다 캐시에서는 데이터를 삭제**한다.
- 저장소에서 특정 데이터를 삭제하는 것이 새로운 데이터를 저장하는 것보다 훨씬 리소스를 적게 사용하기 때문에 앞선 write through 단점을 보완한 방법이라고 볼 수 있다. 

#### 3) write behind(write back)
![write behind](../images/redis/cache-session/4.png)
- 쓰기가 빈번하게 발생한다면, write behind 방식을 고려할 수 있다. **데이터를 먼저 빠르게 접근할 수 있는 캐시에 업데이트한 뒤 이후에 비동기적으로 데이터베이스에 업데이트하는 방식**이다.
- 캐시에 문제가 생겨 데이터가 손실될 수 있는 위험이 존재한다.

### 3. 만료시간 지정하기
- **레디스에서 만료 시간, TTL(Time To Live)은 데이터가 얼마나 오래 저장될 것인지를 나타내는 시간 설정**이다.
- 만료 시간은 일반적으로 초 단위로 표현되며, 지정된 시간이 지난 후 레디스에서 자동으로 삭제한다.
```
127.0.0.1:6379> set a 100
OK
127.0.0.1:6379> expire a 50
(integer) 1
127.0.0.1:6379> TTL a
(integer) 46
127.0.0.1:6379> INCR a
(integer) 101
127.0.0.1:6379> TTL a
(integer) 23
127.0.0.1:6379> RENAME a app
OK
127.0.0.1:6379> TTL app
(integer) -2
```
- `expire` 커맨드는 **키에 대한 만료 시간을 확인**한다.** 키가 존재하지 않을 때는 -2, 키에 대해 만료 시간이 지정되지 않았을 경우 -1을 반환**한다.
- TTL과 EXPIRE 커맨드는 초 단위로, PTTL과 PEXPIRE 커맨드는 밀리 세컨드 단위로 동작한다.
- 기존 키에 새로운 값을 덮어쓸 때 이전에 설정한 만료 시간은 유지되지 않고 사라진다.

#### 레디스 키 삭제 방식
- 키는 Passive 방식과 Active 방식 두 가지로 삭제된다.
- 전자는 **클라이언트가 키에 접근하고자 할 때 키가 만료됐다면 메모리에서 수동적으로 삭제**한다. 사용자가 접근하지 않은 키는 삭제되지 않는다.
- 후자는 **TTL 값이 있는 키 중 20개를 랜덤하게 뽑아낸 뒤, 만료된 키를 모두 메모리에서 삭제한다. 만약 25% 이상의 키가 삭제됐다면 다시 20개의 키를 뽑아 확인하고, 아니라면 뽑아놓은 20개의 키 집합에서 다시 확인한다. 이러한 과정을 1초에 10번씩 수행**한다.
- **만료된 키를 곧바로 삭제하지 않기 때문에 키를 삭제하는 데 들어가는 리소스를 줄일 수 있지만, 그만큼 메모리를 더 사용할 가능성이 존재**한다. 최악의 경우 25% 이미 만료된 키 값일 수 있다.


### 4. 메모리 관리와 maxmemory-policy

#### 1) Noeviction

#### 2) LRU eviction

#### 3) LFU eviction

#### 4) RANDOM eviction

### 5. 캐시 스탬피드 현상

# 레디스 세션으로 사용하기

# 캐시와 세션의 차이
